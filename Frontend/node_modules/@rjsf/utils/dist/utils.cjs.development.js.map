{"version":3,"file":"utils.cjs.development.js","sources":["../src/isObject.ts","../src/allowAdditionalItems.ts","../src/asNumber.ts","../src/constants.ts","../src/getUiOptions.ts","../src/canExpand.ts","../src/createErrorHandler.ts","../src/deepEquals.ts","../src/findSchemaDefinition.ts","../src/schema/getMatchingOption.ts","../src/schema/getFirstMatchingOption.ts","../src/getDiscriminatorFieldFromSchema.ts","../src/guessType.ts","../src/getSchemaType.ts","../src/mergeSchemas.ts","../src/schema/retrieveSchema.ts","../src/schema/getClosestMatchingOption.ts","../src/isFixedItems.ts","../src/mergeDefaultsWithFormData.ts","../src/mergeObjects.ts","../src/isConstant.ts","../src/schema/isSelect.ts","../src/schema/isMultiSelect.ts","../src/schema/getDefaultFormState.ts","../src/isCustomWidget.ts","../src/schema/isFilesArray.ts","../src/schema/getDisplayLabel.ts","../src/schema/mergeValidationData.ts","../src/schema/sanitizeDataForNewSchema.ts","../src/schema/toIdSchema.ts","../src/schema/toPathSchema.ts","../src/createSchemaUtils.ts","../src/dataURItoBlob.ts","../src/replaceStringParameters.ts","../src/englishStringTranslator.ts","../src/enumOptionsValueForIndex.ts","../src/enumOptionsDeselectValue.ts","../src/enumOptionsIsSelected.ts","../src/enumOptionsIndexForValue.ts","../src/enumOptionsSelectValue.ts","../src/ErrorSchemaBuilder.ts","../src/rangeSpec.ts","../src/getInputProps.ts","../src/getSubmitButtonOptions.ts","../src/getTemplate.ts","../src/getWidget.tsx","../src/hashForSchema.ts","../src/hasWidget.ts","../src/idGenerators.ts","../src/labelValue.ts","../src/localToUTC.ts","../src/toConstant.ts","../src/optionsList.ts","../src/orderProperties.ts","../src/pad.ts","../src/parseDateString.ts","../src/schemaRequiresTrueValue.ts","../src/shouldRender.ts","../src/toDateString.ts","../src/toErrorList.ts","../src/toErrorSchema.ts","../src/unwrapErrorHandler.ts","../src/utcToLocal.ts","../src/validationDataMerge.ts","../src/withIdRefPrefix.ts","../src/enums.ts","../src/parser/ParserValidator.ts","../src/parser/schemaParser.ts"],"sourcesContent":["/** Determines whether a `thing` is an object for the purposes of RSJF. In this case, `thing` is an object if it has\n * the type `object` but is NOT null, an array or a File.\n *\n * @param thing - The thing to check to see whether it is an object\n * @returns - True if it is a non-null, non-array, non-File object\n */\nexport default function isObject(thing: any) {\n  if (typeof File !== 'undefined' && thing instanceof File) {\n    return false;\n  }\n  if (typeof Date !== 'undefined' && thing instanceof Date) {\n    return false;\n  }\n  return typeof thing === 'object' && thing !== null && !Array.isArray(thing);\n}\n","import isObject from './isObject';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Checks the schema to see if it is allowing additional items, by verifying that `schema.additionalItems` is an\n * object. The user is warned in the console if `schema.additionalItems` has the value `true`.\n *\n * @param schema - The schema object to check\n * @returns - True if additional items is allowed, otherwise false\n */\nexport default function allowAdditionalItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  if (schema.additionalItems === true) {\n    console.warn('additionalItems=true is currently not supported');\n  }\n  return isObject(schema.additionalItems);\n}\n","/** Attempts to convert the string into a number. If an empty string is provided, then `undefined` is returned. If a\n * `null` is provided, it is returned. If the string ends in a `.` then the string is returned because the user may be\n * in the middle of typing a float number. If a number ends in a pattern like `.0`, `.20`, `.030`, string is returned\n * because the user may be typing number that will end in a non-zero digit. Otherwise, the string is wrapped by\n * `Number()` and if that result is not `NaN`, that number will be returned, otherwise the string `value` will be.\n *\n * @param value - The string or null value to convert to a number\n * @returns - The `value` converted to a number when appropriate, otherwise the `value`\n */\nexport default function asNumber(value: string | null) {\n  if (value === '') {\n    return undefined;\n  }\n  if (value === null) {\n    return null;\n  }\n  if (/\\.$/.test(value)) {\n    // '3.' can't really be considered a number even if it parses in js. The\n    // user is most likely entering a float.\n    return value;\n  }\n  if (/\\.0$/.test(value)) {\n    // we need to return this as a string here, to allow for input like 3.07\n    return value;\n  }\n\n  if (/\\.\\d*0$/.test(value)) {\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\n    // with the user when entering dollar amounts or other values (such as those with\n    // specific precision or number of significant digits)\n    return value;\n  }\n\n  const n = Number(value);\n  const valid = typeof n === 'number' && !Number.isNaN(n);\n\n  return valid ? n : value;\n}\n","/** Below are the list of all the keys into various elements of a RJSFSchema or UiSchema that are used by the various\n * utility functions. In addition to those keys, there are the special `ADDITIONAL_PROPERTY_FLAG` and\n * `RJSF_ADDITONAL_PROPERTIES_FLAG` flags that is added to a schema under certain conditions by the `retrieveSchema()`\n * utility.\n */\nexport const ADDITIONAL_PROPERTY_FLAG = '__additional_property';\nexport const ADDITIONAL_PROPERTIES_KEY = 'additionalProperties';\nexport const ALL_OF_KEY = 'allOf';\nexport const ANY_OF_KEY = 'anyOf';\nexport const CONST_KEY = 'const';\nexport const DEFAULT_KEY = 'default';\nexport const DEFINITIONS_KEY = 'definitions';\nexport const DEPENDENCIES_KEY = 'dependencies';\nexport const ENUM_KEY = 'enum';\nexport const ERRORS_KEY = '__errors';\nexport const ID_KEY = '$id';\nexport const IF_KEY = 'if';\nexport const ITEMS_KEY = 'items';\nexport const JUNK_OPTION_ID = '_$junk_option_schema_id$_';\nexport const NAME_KEY = '$name';\nexport const ONE_OF_KEY = 'oneOf';\nexport const PROPERTIES_KEY = 'properties';\nexport const REQUIRED_KEY = 'required';\nexport const SUBMIT_BTN_OPTIONS_KEY = 'submitButtonOptions';\nexport const REF_KEY = '$ref';\nexport const RJSF_ADDITONAL_PROPERTIES_FLAG = '__rjsf_additionalProperties';\nexport const ROOT_SCHEMA_PREFIX = '__rjsf_rootSchema';\nexport const UI_FIELD_KEY = 'ui:field';\nexport const UI_WIDGET_KEY = 'ui:widget';\nexport const UI_OPTIONS_KEY = 'ui:options';\nexport const UI_GLOBAL_OPTIONS_KEY = 'ui:globalOptions';\n","import { UI_OPTIONS_KEY, UI_WIDGET_KEY } from './constants';\nimport isObject from './isObject';\nimport { FormContextType, GlobalUISchemaOptions, RJSFSchema, StrictRJSFSchema, UIOptionsType, UiSchema } from './types';\n\n/** Get all passed options from ui:options, and ui:<optionName>, returning them in an object with the `ui:`\n * stripped off. Any `globalOptions` will always be returned, unless they are overridden by options in the `uiSchema`.\n *\n * @param [uiSchema={}] - The UI Schema from which to get any `ui:xxx` options\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n * @returns - An object containing all the `ui:xxx` options with the `ui:` stripped off along with all `globalOptions`\n */\nexport default function getUiOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  uiSchema: UiSchema<T, S, F> = {},\n  globalOptions: GlobalUISchemaOptions = {}\n): UIOptionsType<T, S, F> {\n  return Object.keys(uiSchema)\n    .filter((key) => key.indexOf('ui:') === 0)\n    .reduce(\n      (options, key) => {\n        const value = uiSchema[key];\n        if (key === UI_WIDGET_KEY && isObject(value)) {\n          console.error('Setting options via ui:widget object is no longer supported, use ui:options instead');\n          return options;\n        }\n        if (key === UI_OPTIONS_KEY && isObject(value)) {\n          return { ...options, ...value };\n        }\n        return { ...options, [key.substring(3)]: value };\n      },\n      { ...globalOptions }\n    );\n}\n","import { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\nimport getUiOptions from './getUiOptions';\n\n/** Checks whether the field described by `schema`, having the `uiSchema` and `formData` supports expanding. The UI for\n * the field can expand if it has additional properties, is not forced as non-expandable by the `uiSchema` and the\n * `formData` object doesn't already have `schema.maxProperties` elements.\n *\n * @param schema - The schema for the field that is being checked\n * @param [uiSchema={}] - The uiSchema for the field\n * @param [formData] - The formData for the field\n * @returns - True if the schema element has additionalProperties, is expandable, and not at the maxProperties limit\n */\nexport default function canExpand<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  uiSchema: UiSchema<T, S, F> = {},\n  formData?: T\n) {\n  if (!schema.additionalProperties) {\n    return false;\n  }\n  const { expandable = true } = getUiOptions<T, S, F>(uiSchema);\n  if (expandable === false) {\n    return expandable;\n  }\n  // if ui:options.expandable was not explicitly set to false, we can add\n  // another property if we have not exceeded maxProperties yet\n  if (schema.maxProperties !== undefined && formData) {\n    return Object.keys(formData).length < schema.maxProperties;\n  }\n  return true;\n}\n","import isPlainObject from 'lodash/isPlainObject';\n\nimport { ERRORS_KEY } from './constants';\nimport { FieldValidation, FormValidation, GenericObjectType } from './types';\n\n/** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\n *\n * @param formData - The form data around which the error handler is created\n * @returns - A `FormValidation` object based on the `formData` structure\n */\nexport default function createErrorHandler<T = any>(formData: T): FormValidation<T> {\n  const handler: FieldValidation = {\n    // We store the list of errors for this node in a property named __errors\n    // to avoid name collision with a possible sub schema field named\n    // 'errors' (see `utils.toErrorSchema`).\n    [ERRORS_KEY]: [],\n    addError(message: string) {\n      this[ERRORS_KEY]!.push(message);\n    },\n  };\n  if (Array.isArray(formData)) {\n    return formData.reduce((acc, value, key) => {\n      return { ...acc, [key]: createErrorHandler(value) };\n    }, handler);\n  }\n  if (isPlainObject(formData)) {\n    const formObject: GenericObjectType = formData as GenericObjectType;\n    return Object.keys(formObject).reduce((acc, key) => {\n      return { ...acc, [key]: createErrorHandler(formObject[key]) };\n    }, handler as FormValidation<T>);\n  }\n  return handler as FormValidation<T>;\n}\n","import isEqualWith from 'lodash/isEqualWith';\n\n/** Implements a deep equals using the `lodash.isEqualWith` function, that provides a customized comparator that\n * assumes all functions are equivalent.\n *\n * @param a - The first element to compare\n * @param b - The second element to compare\n * @returns - True if the `a` and `b` are deeply equal, false otherwise\n */\nexport default function deepEquals(a: any, b: any): boolean {\n  return isEqualWith(a, b, (obj: any, other: any) => {\n    if (typeof obj === 'function' && typeof other === 'function') {\n      // Assume all functions are equivalent\n      // see https://github.com/rjsf-team/react-jsonschema-form/issues/255\n      return true;\n    }\n    return undefined; // fallback to default isEquals behavior\n  });\n}\n","import jsonpointer from 'jsonpointer';\nimport omit from 'lodash/omit';\n\nimport { REF_KEY } from './constants';\nimport { GenericObjectType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Splits out the value at the `key` in `object` from the `object`, returning an array that contains in the first\n * location, the `object` minus the `key: value` and in the second location the `value`.\n *\n * @param key - The key from the object to extract\n * @param object - The object from which to extract the element\n * @returns - An array with the first value being the object minus the `key` element and the second element being the\n *      value from `object[key]`\n */\nexport function splitKeyElementFromObject(key: string, object: GenericObjectType) {\n  const value = object[key];\n  const remaining = omit(object, [key]);\n  return [remaining, value];\n}\n\n/** Given the name of a `$ref` from within a schema, using the `rootSchema`, look up and return the sub-schema using the\n * path provided by that reference. If `#` is not the first character of the reference, or the path does not exist in\n * the schema, then throw an Error. Otherwise return the sub-schema. Also deals with nested `$ref`s in the sub-schema.\n *\n * @param $ref - The ref string for which the schema definition is desired\n * @param [rootSchema={}] - The root schema in which to search for the definition\n * @returns - The sub-schema within the `rootSchema` which matches the `$ref` if it exists\n * @throws - Error indicating that no schema for that reference exists\n */\nexport default function findSchemaDefinition<S extends StrictRJSFSchema = RJSFSchema>(\n  $ref?: string,\n  rootSchema: S = {} as S\n): S {\n  let ref = $ref || '';\n  if (ref.startsWith('#')) {\n    // Decode URI fragment representation.\n    ref = decodeURIComponent(ref.substring(1));\n  } else {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  const current: S = jsonpointer.get(rootSchema, ref);\n  if (current === undefined) {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  if (current[REF_KEY]) {\n    const [remaining, theRef] = splitKeyElementFromObject(REF_KEY, current);\n    const subSchema = findSchemaDefinition<S>(theRef, rootSchema);\n    if (Object.keys(remaining).length > 0) {\n      return { ...remaining, ...subSchema };\n    }\n    return subSchema;\n  }\n  return current;\n}\n","import get from 'lodash/get';\nimport has from 'lodash/has';\n\nimport { PROPERTIES_KEY } from '../constants';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\n\n/** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n * Deprecated, use `getFirstMatchingOption()` instead.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the matched option or 0 if none is available\n * @deprecated\n */\nexport default function getMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  formData: T | undefined,\n  options: S[],\n  rootSchema: S,\n  discriminatorField?: string\n): number {\n  // For performance, skip validating subschemas if formData is undefined. We just\n  // want to get the first option in that case.\n  if (formData === undefined) {\n    return 0;\n  }\n  for (let i = 0; i < options.length; i++) {\n    const option = options[i];\n\n    // If we have a discriminator field, then we will use this to make the determination\n    if (discriminatorField && has(option, [PROPERTIES_KEY, discriminatorField])) {\n      const value = get(formData, discriminatorField);\n      const discriminator = get(option, [PROPERTIES_KEY, discriminatorField], {});\n      if (validator.isValid(discriminator, value, rootSchema)) {\n        return i;\n      }\n    } else if (option[PROPERTIES_KEY]) {\n      // If the schema describes an object then we need to add slightly more\n      // strict matching to the schema, because unless the schema uses the\n      // \"requires\" keyword, an object will match the schema as long as it\n      // doesn't have matching keys with a conflicting type. To do this we use an\n      // \"anyOf\" with an array of requires. This augmentation expresses that the\n      // schema should match if any of the keys in the schema are present on the\n      // object and pass validation.\n      //\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      const requiresAnyOf = {\n        anyOf: Object.keys(option[PROPERTIES_KEY]).map((key) => ({\n          required: [key],\n        })),\n      };\n\n      let augmentedSchema;\n\n      // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        const { ...shallowClone } = option;\n\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n\n        shallowClone.allOf.push(requiresAnyOf);\n\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = Object.assign({}, option, requiresAnyOf);\n      }\n\n      // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n      delete augmentedSchema.required;\n\n      if (validator.isValid(augmentedSchema, formData, rootSchema)) {\n        return i;\n      }\n    } else if (validator.isValid(option, formData, rootSchema)) {\n      return i;\n    }\n  }\n  return 0;\n}\n","import getMatchingOption from './getMatchingOption';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\n\n/** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\n * Always returns the first option if there is nothing that matches.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the first matched option or 0 if none is available\n */\nexport default function getFirstMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  formData: T | undefined,\n  options: S[],\n  rootSchema: S,\n  discriminatorField?: string\n): number {\n  return getMatchingOption<T, S, F>(validator, formData, options, rootSchema, discriminatorField);\n}\n","import get from 'lodash/get';\nimport isString from 'lodash/isString';\n\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Returns the `discriminator.propertyName` when defined in the `schema` if it is a string. A warning is generated when\n * it is not a string. Returns `undefined` when a valid discriminator is not present.\n *\n * @param schema - The schema from which the discriminator is potentially obtained\n * @returns - The `discriminator.propertyName` if it exists in the schema, otherwise `undefined`\n */\nexport default function getDiscriminatorFieldFromSchema<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  let discriminator: string | undefined;\n  const maybeString = get(schema, 'discriminator.propertyName', undefined);\n  if (isString(maybeString)) {\n    discriminator = maybeString;\n  } else if (maybeString !== undefined) {\n    console.warn(`Expecting discriminator to be a string, got \"${typeof maybeString}\" instead`);\n  }\n  return discriminator;\n}\n","/** Given a specific `value` attempts to guess the type of a schema element. In the case where we have to implicitly\n *  create a schema, it is useful to know what type to use based on the data we are defining.\n *\n * @param value - The value from which to guess the type\n * @returns - The best guess for the object type\n */\nexport default function guessType(value: any) {\n  if (Array.isArray(value)) {\n    return 'array';\n  }\n  if (typeof value === 'string') {\n    return 'string';\n  }\n  if (value == null) {\n    return 'null';\n  }\n  if (typeof value === 'boolean') {\n    return 'boolean';\n  }\n  if (!isNaN(value)) {\n    return 'number';\n  }\n  if (typeof value === 'object') {\n    return 'object';\n  }\n  // Default to string if we can't figure it out\n  return 'string';\n}\n","import guessType from './guessType';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Gets the type of a given `schema`. If the type is not explicitly defined, then an attempt is made to infer it from\n * other elements of the schema as follows:\n * - schema.const: Returns the `guessType()` of that value\n * - schema.enum: Returns `string`\n * - schema.properties: Returns `object`\n * - schema.additionalProperties: Returns `object`\n * - type is an array with a length of 2 and one type is 'null': Returns the other type\n *\n * @param schema - The schema for which to get the type\n * @returns - The type of the schema\n */\nexport default function getSchemaType<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S\n): string | string[] | undefined {\n  let { type } = schema;\n\n  if (!type && schema.const) {\n    return guessType(schema.const);\n  }\n\n  if (!type && schema.enum) {\n    return 'string';\n  }\n\n  if (!type && (schema.properties || schema.additionalProperties)) {\n    return 'object';\n  }\n\n  if (Array.isArray(type) && type.length === 2 && type.includes('null')) {\n    type = type.find((type) => type !== 'null');\n  }\n\n  return type;\n}\n","import union from 'lodash/union';\n\nimport { REQUIRED_KEY } from './constants';\nimport getSchemaType from './getSchemaType';\nimport isObject from './isObject';\nimport { GenericObjectType } from './types';\n\n/** Recursively merge deeply nested schemas. The difference between `mergeSchemas` and `mergeObjects` is that\n * `mergeSchemas` only concats arrays for values under the 'required' keyword, and when it does, it doesn't include\n * duplicate values.\n *\n * @param obj1 - The first schema object to merge\n * @param obj2 - The second schema object to merge\n * @returns - The merged schema object\n */\nexport default function mergeSchemas(obj1: GenericObjectType, obj2: GenericObjectType) {\n  const acc = Object.assign({}, obj1); // Prevent mutation of source object.\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeSchemas(left, right);\n    } else if (\n      obj1 &&\n      obj2 &&\n      (getSchemaType(obj1) === 'object' || getSchemaType(obj2) === 'object') &&\n      key === REQUIRED_KEY &&\n      Array.isArray(left) &&\n      Array.isArray(right)\n    ) {\n      // Don't include duplicate values when merging 'required' fields.\n      acc[key] = union(left, right);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, acc);\n}\n","import get from 'lodash/get';\nimport set from 'lodash/set';\nimport times from 'lodash/times';\nimport transform from 'lodash/transform';\nimport mergeAllOf, { Options } from 'json-schema-merge-allof';\n\nimport {\n  ADDITIONAL_PROPERTIES_KEY,\n  ADDITIONAL_PROPERTY_FLAG,\n  ALL_OF_KEY,\n  ANY_OF_KEY,\n  DEPENDENCIES_KEY,\n  IF_KEY,\n  ONE_OF_KEY,\n  REF_KEY,\n  PROPERTIES_KEY,\n  ITEMS_KEY,\n} from '../constants';\nimport findSchemaDefinition, { splitKeyElementFromObject } from '../findSchemaDefinition';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport guessType from '../guessType';\nimport isObject from '../isObject';\nimport mergeSchemas from '../mergeSchemas';\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getFirstMatchingOption from './getFirstMatchingOption';\n\n/** Retrieves an expanded schema that has had all of its conditions, additional properties, references and dependencies\n * resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData` that is used to do the\n * potentially recursive resolution.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n */\nexport default function retrieveSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S = {} as S, rawFormData?: T): S {\n  return retrieveSchemaInternal<T, S, F>(validator, schema, rootSchema, rawFormData)[0];\n}\n\n/** Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch\n * with the rest of the schema. If `expandAllBranches` is true, then the `retrieveSchemaInteral()` results for both\n * conditions will be returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that is used to detect valid schema conditions\n * @param schema - The schema for which resolving a condition is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - A list of schemas with the appropriate conditions resolved, possibly with all branches expanded\n */\nexport function resolveCondition<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  formData?: T\n): S[] {\n  const { if: expression, then, else: otherwise, ...resolvedSchemaLessConditional } = schema;\n\n  const conditionValue = validator.isValid(expression as S, formData || ({} as T), rootSchema);\n  let resolvedSchemas = [resolvedSchemaLessConditional as S];\n  let schemas: S[] = [];\n  if (expandAllBranches) {\n    if (then && typeof then !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(validator, then as S, rootSchema, formData, expandAllBranches)\n      );\n    }\n    if (otherwise && typeof otherwise !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(validator, otherwise as S, rootSchema, formData, expandAllBranches)\n      );\n    }\n  } else {\n    const conditionalSchema = conditionValue ? then : otherwise;\n    if (conditionalSchema && typeof conditionalSchema !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(validator, conditionalSchema as S, rootSchema, formData, expandAllBranches)\n      );\n    }\n  }\n  if (schemas.length) {\n    resolvedSchemas = schemas.map((s) => mergeSchemas(resolvedSchemaLessConditional, s) as S);\n  }\n  return resolvedSchemas.flatMap((s) =>\n    retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches)\n  );\n}\n\n/** Given a list of lists of allOf, anyOf or oneOf values, create a list of lists of all permutations of the values. The\n * `listOfLists` is expected to be all resolved values of the 1st...nth schemas within an `allOf`, `anyOf` or `oneOf`.\n * From those lists, build a matrix for each `xxxOf` where there is more than one schema for a row in the list of lists.\n *\n * For example:\n * - If there are three xxxOf rows (A, B, C) and they have been resolved such that there is only one A, two B and three\n *   C schemas then:\n *   - The permutation for the first row is `[[A]]`\n *   - The permutations for the second row are `[[A,B1], [A,B2]]`\n *   - The permutations for the third row are `[[A,B1,C1], [A,B1,C2], [A,B1,C3], [A,B2,C1], [A,B2,C2], [A,B2,C3]]`\n *\n * @param listOfLists - The list of lists of elements that represent the allOf, anyOf or oneOf resolved values in order\n * @returns - The list of all permutations of schemas for a set of `xxxOf`s\n */\nexport function getAllPermutationsOfXxxOf<S extends StrictRJSFSchema = RJSFSchema>(listOfLists: S[][]) {\n  const allPermutations: S[][] = listOfLists.reduce<S[][]>(\n    (permutations, list) => {\n      // When there are more than one set of schemas for a row, duplicate the set of permutations and add in the values\n      if (list.length > 1) {\n        return list.flatMap((element) => times(permutations.length, (i) => [...permutations[i]].concat(element)));\n      }\n      // Otherwise just push in the single value into the current set of permutations\n      permutations.forEach((permutation) => permutation.push(list[0]));\n      return permutations;\n    },\n    [[]] as S[][] // Start with an empty list\n  );\n\n  return allPermutations;\n}\n\n/** Resolves references and dependencies within a schema and its 'allOf' children. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `resolveDependencies()` helper calls. If\n * `expandAllBranches` is true, then all possible dependencies and/or allOf branches are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas having its references, dependencies and allOf schemas resolved\n */\nexport function resolveSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  formData?: T\n): S[] {\n  if (REF_KEY in schema) {\n    return resolveReference<T, S, F>(validator, schema, rootSchema, expandAllBranches, formData);\n  }\n  if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchemas = resolveDependencies<T, S, F>(validator, schema, rootSchema, expandAllBranches, formData);\n    return resolvedSchemas.flatMap((s) => {\n      return retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches);\n    });\n  }\n  if (ALL_OF_KEY in schema && Array.isArray(schema.allOf)) {\n    const allOfSchemaElements: S[][] = schema.allOf.map((allOfSubschema) =>\n      retrieveSchemaInternal<T, S, F>(validator, allOfSubschema as S, rootSchema, formData, expandAllBranches)\n    );\n    const allPermutations = getAllPermutationsOfXxxOf<S>(allOfSchemaElements);\n    return allPermutations.map((permutation) => ({ ...schema, allOf: permutation }));\n  }\n  // No $ref or dependencies or allOf attribute was found, returning the original schema.\n  return [schema];\n}\n\n/** Resolves references within a schema and then returns the `retrieveSchemaInternal()` of the resolved schema. Passes\n * the `expandAllBranches` flag down to the `retrieveSchemaInternal()` helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a reference is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list schemas retrieved after having all references resolved\n */\nexport function resolveReference<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  formData?: T\n): S[] {\n  // Drop the $ref property of the source schema.\n  const { $ref, ...localSchema } = schema;\n  // Retrieve the referenced schema definition.\n  const refSchema = findSchemaDefinition<S>($ref, rootSchema);\n  // Update referenced schema definition with local schema properties.\n  return retrieveSchemaInternal<T, S, F>(\n    validator,\n    { ...refSchema, ...localSchema },\n    rootSchema,\n    formData,\n    expandAllBranches\n  );\n}\n\n/** Resolves all references within a schema's properties and array items.\n *\n * @param schema - The schema for which resolving all references is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @returns - given schema will all references resolved\n */\nexport function resolveAllReferences<S extends StrictRJSFSchema = RJSFSchema>(schema: S, rootSchema: S): S {\n  let resolvedSchema: S = schema;\n  // resolve top level ref\n  if (REF_KEY in resolvedSchema) {\n    const { $ref, ...localSchema } = resolvedSchema;\n    // Retrieve the referenced schema definition.\n    const refSchema = findSchemaDefinition<S>($ref, rootSchema);\n    resolvedSchema = { ...refSchema, ...localSchema };\n  }\n\n  if (PROPERTIES_KEY in resolvedSchema) {\n    const updatedProps = transform(\n      resolvedSchema[PROPERTIES_KEY]!,\n      (result, value, key: string) => {\n        result[key] = resolveAllReferences(value as S, rootSchema);\n      },\n      {} as RJSFSchema\n    );\n    resolvedSchema = { ...resolvedSchema, [PROPERTIES_KEY]: updatedProps };\n  }\n\n  if (\n    ITEMS_KEY in resolvedSchema &&\n    !Array.isArray(resolvedSchema.items) &&\n    typeof resolvedSchema.items !== 'boolean'\n  ) {\n    resolvedSchema = { ...resolvedSchema, items: resolveAllReferences(resolvedSchema.items as S, rootSchema) };\n  }\n\n  return resolvedSchema;\n}\n\n/** Creates new 'properties' items for each key in the `formData`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the existing additional properties is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s * @param validator\n * @param [aFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The updated schema with additional properties stubbed\n */\nexport function stubExistingAdditionalProperties<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, theSchema: S, rootSchema?: S, aFormData?: T): S {\n  // Clone the schema so that we don't ruin the consumer's original\n  const schema = {\n    ...theSchema,\n    properties: { ...theSchema.properties },\n  };\n\n  // make sure formData is an object\n  const formData: GenericObjectType = aFormData && isObject(aFormData) ? aFormData : {};\n  Object.keys(formData).forEach((key) => {\n    if (key in schema.properties) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    let additionalProperties: S['additionalProperties'] = {};\n    if (typeof schema.additionalProperties !== 'boolean') {\n      if (REF_KEY in schema.additionalProperties!) {\n        additionalProperties = retrieveSchema<T, S, F>(\n          validator,\n          { $ref: get(schema.additionalProperties, [REF_KEY]) } as S,\n          rootSchema,\n          formData as T\n        );\n      } else if ('type' in schema.additionalProperties!) {\n        additionalProperties = { ...schema.additionalProperties };\n      } else if (ANY_OF_KEY in schema.additionalProperties! || ONE_OF_KEY in schema.additionalProperties!) {\n        additionalProperties = {\n          type: 'object',\n          ...schema.additionalProperties,\n        };\n      } else {\n        additionalProperties = { type: guessType(get(formData, [key])) };\n      }\n    } else {\n      additionalProperties = { type: guessType(get(formData, [key])) };\n    }\n\n    // The type of our new key should match the additionalProperties value;\n    schema.properties[key] = additionalProperties;\n    // Set our additional property flag so we know it was dynamically added\n    set(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);\n  });\n\n  return schema;\n}\n\n/** Internal handler that retrieves an expanded schema that has had all of its conditions, additional properties,\n * references and dependencies resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData`\n * that is used to do the potentially recursive resolution. If `expandAllBranches` is true, then all possible branches\n * of the schema and its references, conditions and dependencies are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @param [expandAllBranches=false] - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @returns - The schema(s) resulting from having its conditions, additional properties, references and dependencies\n *          resolved. Multiple schemas may be returned if `expandAllBranches` is true.\n */\nexport function retrieveSchemaInternal<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S, rawFormData?: T, expandAllBranches = false): S[] {\n  if (!isObject(schema)) {\n    return [{} as S];\n  }\n  const resolvedSchemas = resolveSchema<T, S, F>(validator, schema, rootSchema, expandAllBranches, rawFormData);\n  return resolvedSchemas.flatMap((s: S) => {\n    let resolvedSchema = s;\n    if (IF_KEY in resolvedSchema) {\n      return resolveCondition<T, S, F>(validator, resolvedSchema, rootSchema, expandAllBranches, rawFormData as T);\n    }\n    if (ALL_OF_KEY in resolvedSchema) {\n      // resolve allOf schemas\n      if (expandAllBranches) {\n        return [...(resolvedSchema.allOf as S[])];\n      }\n      try {\n        resolvedSchema = mergeAllOf(resolvedSchema, {\n          deep: false,\n        } as Options) as S;\n      } catch (e) {\n        console.warn('could not merge subschemas in allOf:\\n', e);\n        const { allOf, ...resolvedSchemaWithoutAllOf } = resolvedSchema;\n        return resolvedSchemaWithoutAllOf as S;\n      }\n    }\n    const hasAdditionalProperties =\n      ADDITIONAL_PROPERTIES_KEY in resolvedSchema && resolvedSchema.additionalProperties !== false;\n    if (hasAdditionalProperties) {\n      return stubExistingAdditionalProperties<T, S, F>(validator, resolvedSchema, rootSchema, rawFormData as T);\n    }\n\n    return resolvedSchema;\n  });\n}\n\n/** Resolves an `anyOf` or `oneOf` within a schema (if present) to the list of schemas returned from\n * `retrieveSchemaInternal()` for the best matching option. If `expandAllBranches` is true, then a list of schemas for ALL\n * options are retrieved and returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema, defaults to an empty object\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function resolveAnyOrOneOfSchemas<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S, expandAllBranches: boolean, rawFormData?: T) {\n  let anyOrOneOf: S[] | undefined;\n  const { oneOf, anyOf, ...remaining } = schema;\n  if (Array.isArray(oneOf)) {\n    anyOrOneOf = oneOf as S[];\n  } else if (Array.isArray(anyOf)) {\n    anyOrOneOf = anyOf as S[];\n  }\n  if (anyOrOneOf) {\n    // Ensure that during expand all branches we pass an object rather than undefined so that all options are interrogated\n    const formData = rawFormData === undefined && expandAllBranches ? ({} as T) : rawFormData;\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    anyOrOneOf = anyOrOneOf.map((s) => {\n      return resolveAllReferences(s, rootSchema);\n    });\n    // Call this to trigger the set of isValid() calls that the schema parser will need\n    const option = getFirstMatchingOption<T, S, F>(validator, formData, anyOrOneOf, rootSchema, discriminator);\n    if (expandAllBranches) {\n      return anyOrOneOf.map((item) => mergeSchemas(remaining, item) as S);\n    }\n    schema = mergeSchemas(remaining, anyOrOneOf[option]) as S;\n  }\n  return [schema];\n}\n\n/** Resolves dependencies within a schema and its 'anyOf/oneOf' children. Passes the `expandAllBranches` flag down to\n * the `resolveAnyOrOneOfSchema()` and `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependency is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas with their dependencies resolved\n */\nexport function resolveDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  formData?: T\n): S[] {\n  // Drop the dependencies from the source schema.\n  const { dependencies, ...remainingSchema } = schema;\n  const resolvedSchemas = resolveAnyOrOneOfSchemas<T, S, F>(\n    validator,\n    remainingSchema as S,\n    rootSchema,\n    expandAllBranches,\n    formData\n  );\n  return resolvedSchemas.flatMap((resolvedSchema) =>\n    processDependencies<T, S, F>(validator, dependencies, resolvedSchema, rootSchema, expandAllBranches, formData)\n  );\n}\n\n/** Processes all the `dependencies` recursively into the list of `resolvedSchema`s as needed. Passes the\n * `expandAllBranches` flag down to the `withDependentSchema()` and the recursive `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param dependencies - The set of dependencies that needs to be processed\n * @param resolvedSchema - The schema for which processing dependencies is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema with the `dependencies` resolved into it\n */\nexport function processDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  dependencies: S['dependencies'],\n  resolvedSchema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  formData?: T\n): S[] {\n  let schemas = [resolvedSchema];\n  // Process dependencies updating the local schema properties as appropriate.\n  for (const dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (!expandAllBranches && get(formData, [dependencyKey]) === undefined) {\n      continue;\n    }\n    // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {\n      continue;\n    }\n    const [remainingDependencies, dependencyValue] = splitKeyElementFromObject(\n      dependencyKey,\n      dependencies as GenericObjectType\n    );\n    if (Array.isArray(dependencyValue)) {\n      schemas[0] = withDependentProperties<S>(resolvedSchema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      schemas = withDependentSchema<T, S, F>(\n        validator,\n        resolvedSchema,\n        rootSchema,\n        dependencyKey,\n        dependencyValue as S,\n        expandAllBranches,\n        formData\n      );\n    }\n    return schemas.flatMap((schema) =>\n      processDependencies<T, S, F>(validator, remainingDependencies, schema, rootSchema, expandAllBranches, formData)\n    );\n  }\n  return schemas;\n}\n\n/** Updates a schema with additionally required properties added\n *\n * @param schema - The schema for which resolving a dependent properties is desired\n * @param [additionallyRequired] - An optional array of additionally required names\n * @returns - The schema with the additional required values merged in\n */\nexport function withDependentProperties<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  additionallyRequired?: string[]\n) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n  const required = Array.isArray(schema.required)\n    ? Array.from(new Set([...schema.required, ...additionallyRequired]))\n    : additionallyRequired;\n  return { ...schema, required: required };\n}\n\n/** Merges a dependent schema into the `schema` dealing with oneOfs and references. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `withExactlyOneSubschema()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependent schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the dependency\n * @param dependencyValue - The potentially dependent schema\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param [formData]- The current formData to assist retrieving a schema\n * @returns - The list of schemas with the dependent schema resolved into them\n */\nexport function withDependentSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  dependencyValue: S,\n  expandAllBranches: boolean,\n  formData?: T\n): S[] {\n  const dependentSchemas = retrieveSchemaInternal<T, S, F>(\n    validator,\n    dependencyValue,\n    rootSchema,\n    formData,\n    expandAllBranches\n  );\n  return dependentSchemas.flatMap((dependent) => {\n    const { oneOf, ...dependentSchema } = dependent;\n    schema = mergeSchemas(schema, dependentSchema) as S;\n    // Since it does not contain oneOf, we return the original schema.\n    if (oneOf === undefined) {\n      return schema;\n    }\n    // Resolve $refs inside oneOf.\n    const resolvedOneOfs = oneOf.map((subschema) => {\n      if (typeof subschema === 'boolean' || !(REF_KEY in subschema)) {\n        return [subschema as S];\n      }\n      return resolveReference<T, S, F>(validator, subschema as S, rootSchema, expandAllBranches, formData);\n    });\n    const allPermutations = getAllPermutationsOfXxxOf(resolvedOneOfs);\n    return allPermutations.flatMap((resolvedOneOf) =>\n      withExactlyOneSubschema<T, S, F>(\n        validator,\n        schema,\n        rootSchema,\n        dependencyKey,\n        resolvedOneOf,\n        expandAllBranches,\n        formData\n      )\n    );\n  });\n}\n\n/** Returns a list of `schema`s with the best choice from the `oneOf` options merged into it. If `expandAllBranches` is\n * true, then a list of schemas for ALL options are retrieved and returned. Passes the `expandAllBranches` flag down to\n * the `retrieveSchemaInternal()` helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used to validate oneOf options\n * @param schema - The schema for which resolving a oneOf subschema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the oneOf dependency\n * @param oneOf - The list of schemas representing the oneOf options\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function withExactlyOneSubschema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  oneOf: S['oneOf'],\n  expandAllBranches: boolean,\n  formData?: T\n): S[] {\n  const validSubschemas = oneOf!.filter((subschema) => {\n    if (typeof subschema === 'boolean' || !subschema || !subschema.properties) {\n      return false;\n    }\n    const { [dependencyKey]: conditionPropertySchema } = subschema.properties;\n    if (conditionPropertySchema) {\n      const conditionSchema: S = {\n        type: 'object',\n        properties: {\n          [dependencyKey]: conditionPropertySchema,\n        },\n      } as S;\n      return validator.isValid(conditionSchema, formData, rootSchema) || expandAllBranches;\n    }\n    return false;\n  });\n\n  if (!expandAllBranches && validSubschemas!.length !== 1) {\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\n    return [schema];\n  }\n  return validSubschemas.flatMap((s) => {\n    const subschema: S = s as S;\n    const [dependentSubschema] = splitKeyElementFromObject(dependencyKey, subschema.properties as GenericObjectType);\n    const dependentSchema = { ...subschema, properties: dependentSubschema };\n    const schemas = retrieveSchemaInternal<T, S, F>(\n      validator,\n      dependentSchema,\n      rootSchema,\n      formData,\n      expandAllBranches\n    );\n    return schemas.map((s) => mergeSchemas(schema, s) as S);\n  });\n}\n","import get from 'lodash/get';\nimport has from 'lodash/has';\nimport isObject from 'lodash/isObject';\nimport isString from 'lodash/isString';\nimport reduce from 'lodash/reduce';\nimport times from 'lodash/times';\n\nimport getFirstMatchingOption from './getFirstMatchingOption';\nimport retrieveSchema, { resolveAllReferences } from './retrieveSchema';\nimport { ONE_OF_KEY, REF_KEY, JUNK_OPTION_ID, ANY_OF_KEY } from '../constants';\nimport guessType from '../guessType';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\n\n/** A junk option used to determine when the getFirstMatchingOption call really matches an option rather than returning\n * the first item\n */\nexport const JUNK_OPTION: StrictRJSFSchema = {\n  type: 'object',\n  $id: JUNK_OPTION_ID,\n  properties: {\n    __not_really_there__: {\n      type: 'number',\n    },\n  },\n};\n\n/** Recursive function that calculates the score of a `formData` against the given `schema`. The computation is fairly\n * simple. Initially the total score is 0. When `schema.properties` object exists, then all the `key/value` pairs within\n * the object are processed as follows after obtaining the formValue from `formData` using the `key`:\n * - If the `value` contains a `$ref`, `calculateIndexScore()` is called recursively with the formValue and the new\n *   schema that is the result of the ref in the schema being resolved and that sub-schema's resulting score is added to\n *   the total.\n * - If the `value` contains a `oneOf` and there is a formValue, then score based on the index returned from calling\n *   `getClosestMatchingOption()` of that oneOf.\n * - If the type of the `value` is 'object', `calculateIndexScore()` is called recursively with the formValue and the\n *   `value` itself as the sub-schema, and the score is added to the total.\n * - If the type of the `value` matches the guessed-type of the `formValue`, the score is incremented by 1, UNLESS the\n *   value has a `default` or `const`. In those case, if the `default` or `const` and the `formValue` match, the score\n *   is incremented by another 1 otherwise it is decremented by 1.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param schema - The schema for which the score is being calculated\n * @param formData - The form data associated with the schema, used to calculate the score\n * @returns - The score a schema against the formData\n */\nexport function calculateIndexScore<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  schema?: S,\n  formData: any = {}\n): number {\n  let totalScore = 0;\n  if (schema) {\n    if (isObject(schema.properties)) {\n      totalScore += reduce(\n        schema.properties,\n        (score, value, key) => {\n          const formValue = get(formData, key);\n          if (typeof value === 'boolean') {\n            return score;\n          }\n          if (has(value, REF_KEY)) {\n            const newSchema = retrieveSchema<T, S, F>(validator, value as S, rootSchema, formValue);\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, newSchema, formValue || {});\n          }\n          if ((has(value, ONE_OF_KEY) || has(value, ANY_OF_KEY)) && formValue) {\n            const key = has(value, ONE_OF_KEY) ? ONE_OF_KEY : ANY_OF_KEY;\n            const discriminator = getDiscriminatorFieldFromSchema<S>(value as S);\n            return (\n              score +\n              getClosestMatchingOption<T, S, F>(\n                validator,\n                rootSchema,\n                formValue,\n                get(value, key) as S[],\n                -1,\n                discriminator\n              )\n            );\n          }\n          if (value.type === 'object') {\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, value as S, formValue || {});\n          }\n          if (value.type === guessType(formValue)) {\n            // If the types match, then we bump the score by one\n            let newScore = score + 1;\n            if (value.default) {\n              // If the schema contains a readonly default value score the value that matches the default higher and\n              // any non-matching value lower\n              newScore += formValue === value.default ? 1 : -1;\n            } else if (value.const) {\n              // If the schema contains a const value score the value that matches the default higher and\n              // any non-matching value lower\n              newScore += formValue === value.const ? 1 : -1;\n            }\n            // TODO eventually, deal with enums/arrays\n            return newScore;\n          }\n          return score;\n        },\n        0\n      );\n    } else if (isString(schema.type) && schema.type === guessType(formData)) {\n      totalScore += 1;\n    }\n  }\n  return totalScore;\n}\n\n/** Determines which of the given `options` provided most closely matches the `formData`. Using\n * `getFirstMatchingOption()` to match two schemas that differ only by the readOnly, default or const value of a field\n * based on the `formData` and returns 0 when there is no match. Rather than passing in all the `options` at once to\n * this utility, instead an array of valid option indexes is created by iterating over the list of options, call\n * `getFirstMatchingOptions` with a list of one junk option and one good option, seeing if the good option is considered\n * matched.\n *\n * Once the list of valid indexes is created, if there is only one valid index, just return it. Otherwise, if there are\n * no valid indexes, then fill the valid indexes array with the indexes of all the options. Next, the index of the\n * option with the highest score is determined by iterating over the list of valid options, calling\n * `calculateIndexScore()` on each, comparing it against the current best score, and returning the index of the one that\n * eventually has the best score.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param formData - The form data associated with the schema\n * @param options - The list of options that can be selected from\n * @param [selectedOption=-1] - The index of the currently selected option, defaulted to -1 if not specified\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n */\nexport default function getClosestMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  formData: T | undefined,\n  options: S[],\n  selectedOption = -1,\n  discriminatorField?: string\n): number {\n  // First resolve any refs in the options\n  const resolvedOptions = options.map((option) => {\n    return resolveAllReferences(option, rootSchema);\n  });\n  // Reduce the array of options down to a list of the indexes that are considered matching options\n  const allValidIndexes = resolvedOptions.reduce((validList: number[], option, index: number) => {\n    const testOptions: S[] = [JUNK_OPTION as S, option];\n    const match = getFirstMatchingOption<T, S, F>(validator, formData, testOptions, rootSchema, discriminatorField);\n    // The match is the real option, so add its index to list of valid indexes\n    if (match === 1) {\n      validList.push(index);\n    }\n    return validList;\n  }, []);\n\n  // There is only one valid index, so return it!\n  if (allValidIndexes.length === 1) {\n    return allValidIndexes[0];\n  }\n  if (!allValidIndexes.length) {\n    // No indexes were valid, so we'll score all the options, add all the indexes\n    times(resolvedOptions.length, (i) => allValidIndexes.push(i));\n  }\n  type BestType = { bestIndex: number; bestScore: number };\n  const scoreCount = new Set<number>();\n  // Score all the options in the list of valid indexes and return the index with the best score\n  const { bestIndex }: BestType = allValidIndexes.reduce(\n    (scoreData: BestType, index: number) => {\n      const { bestScore } = scoreData;\n      const option = resolvedOptions[index];\n      const score = calculateIndexScore(validator, rootSchema, option, formData);\n      scoreCount.add(score);\n      if (score > bestScore) {\n        return { bestIndex: index, bestScore: score };\n      }\n      return scoreData;\n    },\n    { bestIndex: selectedOption, bestScore: 0 }\n  );\n  // if all scores are the same go with selectedOption\n  if (scoreCount.size === 1 && selectedOption >= 0) {\n    return selectedOption;\n  }\n\n  return bestIndex;\n}\n","import isObject from './isObject';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Detects whether the given `schema` contains fixed items. This is the case when `schema.items` is a non-empty array\n * that only contains objects.\n *\n * @param schema - The schema in which to check for fixed items\n * @returns - True if there are fixed items in the schema, false otherwise\n */\nexport default function isFixedItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  return Array.isArray(schema.items) && schema.items.length > 0 && schema.items.every((item) => isObject(item));\n}\n","import get from 'lodash/get';\n\nimport isObject from './isObject';\nimport { GenericObjectType } from '../src';\n\n/** Merges the `defaults` object of type `T` into the `formData` of type `T`\n *\n * When merging defaults and form data, we want to merge in this specific way:\n * - objects are deeply merged\n * - arrays are merged in such a way that:\n *   - when the array is set in form data, only array entries set in form data\n *     are deeply merged; additional entries from the defaults are ignored unless `mergeExtraArrayDefaults` is true, in\n *     which case the extras are appended onto the end of the form data\n *   - when the array is not set in form data, the default is copied over\n * - scalars are overwritten/set by form data\n *\n * @param [defaults] - The defaults to merge\n * @param [formData] - The form data into which the defaults will be merged\n * @param [mergeExtraArrayDefaults=false] - If true, any additional default array entries are appended onto the formData\n * @returns - The resulting merged form data with defaults\n */\nexport default function mergeDefaultsWithFormData<T = any>(\n  defaults?: T,\n  formData?: T,\n  mergeExtraArrayDefaults = false\n): T | undefined {\n  if (Array.isArray(formData)) {\n    const defaultsArray = Array.isArray(defaults) ? defaults : [];\n    const mapped = formData.map((value, idx) => {\n      if (defaultsArray[idx]) {\n        return mergeDefaultsWithFormData<any>(defaultsArray[idx], value, mergeExtraArrayDefaults);\n      }\n      return value;\n    });\n    // Merge any extra defaults when mergeExtraArrayDefaults is true\n    if (mergeExtraArrayDefaults && mapped.length < defaultsArray.length) {\n      mapped.push(...defaultsArray.slice(mapped.length));\n    }\n    return mapped as unknown as T;\n  }\n  if (isObject(formData)) {\n    const acc: { [key in keyof T]: any } = Object.assign({}, defaults); // Prevent mutation of source object.\n    return Object.keys(formData as GenericObjectType).reduce((acc, key) => {\n      acc[key as keyof T] = mergeDefaultsWithFormData<T>(\n        defaults ? get(defaults, key) : {},\n        get(formData, key),\n        mergeExtraArrayDefaults\n      );\n      return acc;\n    }, acc);\n  }\n  return formData;\n}\n","import isObject from './isObject';\nimport { GenericObjectType } from './types';\n\n/** Recursively merge deeply nested objects.\n *\n * @param obj1 - The first object to merge\n * @param obj2 - The second object to merge\n * @param [concatArrays=false] - Optional flag that, when true, will cause arrays to be concatenated. Use\n *          \"preventDuplicates\" to merge arrays in a manner that prevents any duplicate entries from being merged.\n *          NOTE: Uses shallow comparison for the duplicate checking.\n * @returns - A new object that is the merge of the two given objects\n */\nexport default function mergeObjects(\n  obj1: GenericObjectType,\n  obj2: GenericObjectType,\n  concatArrays: boolean | 'preventDuplicates' = false\n) {\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeObjects(left, right, concatArrays);\n    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {\n      let toMerge = right;\n      if (concatArrays === 'preventDuplicates') {\n        toMerge = right.reduce((result, value) => {\n          if (!left.includes(value)) {\n            result.push(value);\n          }\n          return result;\n        }, []);\n      }\n      acc[key] = left.concat(toMerge);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, Object.assign({}, obj1)); // Prevent mutation of source object.\n}\n","import { CONST_KEY } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** This function checks if the given `schema` matches a single constant value. This happens when either the schema has\n * an `enum` array with a single value or there is a `const` defined.\n *\n * @param schema - The schema for a field\n * @returns - True if the `schema` has a single constant value, false otherwise\n */\nexport default function isConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  return (Array.isArray(schema.enum) && schema.enum.length === 1) || CONST_KEY in schema;\n}\n","import isConstant from '../isConstant';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\n\n/** Checks to see if the `schema` combination represents a select\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which check for a select flag is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema contains a select, otherwise false\n */\nexport default function isSelect<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  theSchema: S,\n  rootSchema: S = {} as S\n) {\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, undefined);\n  const altSchemas = schema.oneOf || schema.anyOf;\n  if (Array.isArray(schema.enum)) {\n    return true;\n  }\n  if (Array.isArray(altSchemas)) {\n    return altSchemas.every((altSchemas) => typeof altSchemas !== 'boolean' && isConstant(altSchemas));\n  }\n  return false;\n}\n","import { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\n\nimport isSelect from './isSelect';\n\n/** Checks to see if the `schema` combination represents a multi-select\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which check for a multi-select flag is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema contains a multi-select, otherwise false\n */\nexport default function isMultiSelect<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema?: S) {\n  if (!schema.uniqueItems || !schema.items || typeof schema.items === 'boolean') {\n    return false;\n  }\n  return isSelect<T, S, F>(validator, schema.items as S, rootSchema);\n}\n","import get from 'lodash/get';\nimport isEmpty from 'lodash/isEmpty';\n\nimport { ANY_OF_KEY, DEFAULT_KEY, DEPENDENCIES_KEY, PROPERTIES_KEY, ONE_OF_KEY, REF_KEY } from '../constants';\nimport findSchemaDefinition from '../findSchemaDefinition';\nimport getClosestMatchingOption from './getClosestMatchingOption';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport getSchemaType from '../getSchemaType';\nimport isObject from '../isObject';\nimport isFixedItems from '../isFixedItems';\nimport mergeDefaultsWithFormData from '../mergeDefaultsWithFormData';\nimport mergeObjects from '../mergeObjects';\nimport mergeSchemas from '../mergeSchemas';\nimport {\n  Experimental_DefaultFormStateBehavior,\n  FormContextType,\n  GenericObjectType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  ValidatorType,\n} from '../types';\nimport isMultiSelect from './isMultiSelect';\nimport retrieveSchema, { resolveDependencies } from './retrieveSchema';\n\n/** Enum that indicates how `schema.additionalItems` should be handled by the `getInnerSchemaForArrayItem()` function.\n */\nexport enum AdditionalItemsHandling {\n  Ignore,\n  Invert,\n  Fallback,\n}\n\n/** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the\n * `additionalItems` enum and the value of `idx`. There are four possible returns:\n * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid\n *    index and not a boolean, otherwise it falls through to 3.\n * 2. If `schema.items` is not an array AND truthy and not a boolean, then `schema.items` is returned since it actually\n *    is a schema, otherwise it falls through to 3.\n * 3. If `additionalItems` is not `AdditionalItemsHandling.Ignore` and `schema.additionalItems` is an object, then\n *    `schema.additionalItems` is returned since it actually is a schema, otherwise it falls through to 4.\n * 4. {} is returned representing an empty schema\n *\n * @param schema - The schema from which to get the particular item\n * @param [additionalItems=AdditionalItemsHandling.Ignore] - How do we want to handle additional items?\n * @param [idx=-1] - Index, if non-negative, will be used to return the idx-th element in a `schema.items` array\n * @returns - The best fit schema object from the `schema` given the `additionalItems` and `idx` modifiers\n */\nexport function getInnerSchemaForArrayItem<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  additionalItems: AdditionalItemsHandling = AdditionalItemsHandling.Ignore,\n  idx = -1\n): S {\n  if (idx >= 0) {\n    if (Array.isArray(schema.items) && idx < schema.items.length) {\n      const item = schema.items[idx];\n      if (typeof item !== 'boolean') {\n        return item as S;\n      }\n    }\n  } else if (schema.items && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\n    return schema.items as S;\n  }\n  if (additionalItems !== AdditionalItemsHandling.Ignore && isObject(schema.additionalItems)) {\n    return schema.additionalItems as S;\n  }\n  return {} as S;\n}\n\n/** Either add `computedDefault` at `key` into `obj` or not add it based on its value, the value of\n * `includeUndefinedValues`, the value of `emptyObjectFields` and if its parent field is required. Generally undefined\n * `computedDefault` values are added only when `includeUndefinedValues` is either true/\"excludeObjectChildren\". If `\n * includeUndefinedValues` is false and `emptyObjectFields` is not \"skipDefaults\", then non-undefined and non-empty-object\n * values will be added based on certain conditions.\n *\n * @param obj - The object into which the computed default may be added\n * @param key - The key into the object at which the computed default may be added\n * @param computedDefault - The computed default value that maybe should be added to the obj\n * @param includeUndefinedValues - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties. If \"allowEmptyObject\", prevents undefined\n *          values in this object while allow the object itself to be empty and passing `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param isParentRequired - The optional boolean that indicates whether the parent field is required\n * @param requiredFields - The list of fields that are required\n * @param experimental_defaultFormStateBehavior - Optional configuration object, if provided, allows users to override\n *        default form state behavior\n */\nfunction maybeAddDefaultToObject<T = any>(\n  obj: GenericObjectType,\n  key: string,\n  computedDefault: T | T[] | undefined,\n  includeUndefinedValues: boolean | 'excludeObjectChildren',\n  isParentRequired?: boolean,\n  requiredFields: string[] = [],\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior = {}\n) {\n  const { emptyObjectFields = 'populateAllDefaults' } = experimental_defaultFormStateBehavior;\n  if (includeUndefinedValues) {\n    obj[key] = computedDefault;\n  } else if (emptyObjectFields !== 'skipDefaults') {\n    if (isObject(computedDefault)) {\n      // If isParentRequired is undefined, then we are at the root level of the schema so defer to the requiredness of\n      // the field key itself in the `requiredField` list\n      const isSelfOrParentRequired = isParentRequired === undefined ? requiredFields.includes(key) : isParentRequired;\n      // Store computedDefault if it's a non-empty object(e.g. not {}) and satisfies certain conditions\n      // Condition 1: If computedDefault is not empty or if the key is a required field\n      // Condition 2: If the parent object is required or emptyObjectFields is not 'populateRequiredDefaults'\n      if (\n        (!isEmpty(computedDefault) || requiredFields.includes(key)) &&\n        (isSelfOrParentRequired || emptyObjectFields !== 'populateRequiredDefaults')\n      ) {\n        obj[key] = computedDefault;\n      }\n    } else if (\n      // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions\n      // Condition 1: computedDefault is not undefined\n      // Condition 2: If emptyObjectFields is 'populateAllDefaults' or if the key is a required field\n      computedDefault !== undefined &&\n      (emptyObjectFields === 'populateAllDefaults' || requiredFields.includes(key))\n    ) {\n      obj[key] = computedDefault;\n    }\n  }\n}\n\ninterface ComputeDefaultsProps<T = any, S extends StrictRJSFSchema = RJSFSchema> {\n  parentDefaults?: T;\n  rootSchema?: S;\n  rawFormData?: T;\n  includeUndefinedValues?: boolean | 'excludeObjectChildren';\n  _recurseList?: string[];\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior;\n  required?: boolean;\n}\n\n/** Computes the defaults for the current `schema` given the `rawFormData` and `parentDefaults` if any. This drills into\n * each level of the schema, recursively, to fill out every level of defaults provided by the schema.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary\n * @param rawSchema - The schema for which the default state is desired\n * @param [props] - Optional props for this function\n * @param [props.parentDefaults] - Any defaults provided by the parent field in the schema\n * @param [props.rootSchema] - The options root schema, used to primarily to look up `$ref`s\n * @param [props.rawFormData] - The current formData, if any, onto which to provide any missing defaults\n * @param [props.includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param [props._recurseList=[]] - The list of ref names currently being recursed, used to prevent infinite recursion\n * @param [props.experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @param [props.required] - Optional flag, if true, indicates this schema was required in the parent schema.\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport function computeDefaults<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  rawSchema: S,\n  {\n    parentDefaults,\n    rawFormData,\n    rootSchema = {} as S,\n    includeUndefinedValues = false,\n    _recurseList = [],\n    experimental_defaultFormStateBehavior = undefined,\n    required,\n  }: ComputeDefaultsProps<T, S> = {}\n): T | T[] | undefined {\n  const formData: T = (isObject(rawFormData) ? rawFormData : {}) as T;\n  const schema: S = isObject(rawSchema) ? rawSchema : ({} as S);\n  // Compute the defaults recursively: give highest priority to deepest nodes.\n  let defaults: T | T[] | undefined = parentDefaults;\n  // If we get a new schema, then we need to recompute defaults again for the new schema found.\n  let schemaToCompute: S | null = null;\n  let updatedRecurseList = _recurseList;\n\n  if (isObject(defaults) && isObject(schema.default)) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(defaults!, schema.default as GenericObjectType) as T;\n  } else if (DEFAULT_KEY in schema) {\n    defaults = schema.default as unknown as T;\n  } else if (REF_KEY in schema) {\n    const refName = schema[REF_KEY];\n    // Use referenced schema defaults for this node.\n    if (!_recurseList.includes(refName!)) {\n      updatedRecurseList = _recurseList.concat(refName!);\n      schemaToCompute = findSchemaDefinition<S>(refName, rootSchema);\n    }\n  } else if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchema = resolveDependencies<T, S, F>(validator, schema, rootSchema, false, formData);\n    schemaToCompute = resolvedSchema[0]; // pick the first element from resolve dependencies\n  } else if (isFixedItems(schema)) {\n    defaults = (schema.items! as S[]).map((itemSchema: S, idx: number) =>\n      computeDefaults<T, S>(validator, itemSchema, {\n        rootSchema,\n        includeUndefinedValues,\n        _recurseList,\n        experimental_defaultFormStateBehavior,\n        parentDefaults: Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined,\n        rawFormData: formData as T,\n        required,\n      })\n    ) as T[];\n  } else if (ONE_OF_KEY in schema) {\n    const { oneOf, ...remaining } = schema;\n    if (oneOf!.length === 0) {\n      return undefined;\n    }\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    schemaToCompute = oneOf![\n      getClosestMatchingOption<T, S, F>(\n        validator,\n        rootSchema,\n        isEmpty(formData) ? undefined : formData,\n        oneOf as S[],\n        0,\n        discriminator\n      )\n    ] as S;\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\n  } else if (ANY_OF_KEY in schema) {\n    const { anyOf, ...remaining } = schema;\n    if (anyOf!.length === 0) {\n      return undefined;\n    }\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    schemaToCompute = anyOf![\n      getClosestMatchingOption<T, S, F>(\n        validator,\n        rootSchema,\n        isEmpty(formData) ? undefined : formData,\n        anyOf as S[],\n        0,\n        discriminator\n      )\n    ] as S;\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\n  }\n\n  if (schemaToCompute) {\n    return computeDefaults<T, S, F>(validator, schemaToCompute, {\n      rootSchema,\n      includeUndefinedValues,\n      _recurseList: updatedRecurseList,\n      experimental_defaultFormStateBehavior,\n      parentDefaults: defaults as T | undefined,\n      rawFormData: formData as T,\n      required,\n    });\n  }\n\n  // No defaults defined for this node, fallback to generic typed ones.\n  if (defaults === undefined) {\n    defaults = schema.default as unknown as T;\n  }\n\n  switch (getSchemaType<S>(schema)) {\n    // We need to recurse for object schema inner default values.\n    case 'object': {\n      const objectDefaults = Object.keys(schema.properties || {}).reduce((acc: GenericObjectType, key: string) => {\n        // Compute the defaults for this node, with the parent defaults we might\n        // have from a previous run: defaults[key].\n        const computedDefault = computeDefaults<T, S, F>(validator, get(schema, [PROPERTIES_KEY, key]), {\n          rootSchema,\n          _recurseList,\n          experimental_defaultFormStateBehavior,\n          includeUndefinedValues: includeUndefinedValues === true,\n          parentDefaults: get(defaults, [key]),\n          rawFormData: get(formData, [key]),\n          required: schema.required?.includes(key),\n        });\n        maybeAddDefaultToObject<T>(\n          acc,\n          key,\n          computedDefault,\n          includeUndefinedValues,\n          required,\n          schema.required,\n          experimental_defaultFormStateBehavior\n        );\n        return acc;\n      }, {}) as T;\n      if (schema.additionalProperties) {\n        // as per spec additionalProperties may be either schema or boolean\n        const additionalPropertiesSchema = isObject(schema.additionalProperties) ? schema.additionalProperties : {};\n        const keys = new Set<string>();\n        if (isObject(defaults)) {\n          Object.keys(defaults as GenericObjectType)\n            .filter((key) => !schema.properties || !schema.properties[key])\n            .forEach((key) => keys.add(key));\n        }\n        let formDataRequired: string[];\n        if (isObject(formData)) {\n          formDataRequired = [];\n          Object.keys(formData as GenericObjectType)\n            .filter((key) => !schema.properties || !schema.properties[key])\n            .forEach((key) => {\n              keys.add(key);\n              formDataRequired.push(key);\n            });\n        }\n        keys.forEach((key) => {\n          const computedDefault = computeDefaults(validator, additionalPropertiesSchema as S, {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            includeUndefinedValues: includeUndefinedValues === true,\n            parentDefaults: get(defaults, [key]),\n            rawFormData: get(formData, [key]),\n            required: schema.required?.includes(key),\n          });\n          // Since these are additional properties we dont need to add the `experimental_defaultFormStateBehavior` prop\n          maybeAddDefaultToObject<T>(\n            objectDefaults as GenericObjectType,\n            key,\n            computedDefault,\n            includeUndefinedValues,\n            required,\n            formDataRequired\n          );\n        });\n      }\n      return objectDefaults;\n    }\n    case 'array': {\n      // Inject defaults into existing array defaults\n      if (Array.isArray(defaults)) {\n        defaults = defaults.map((item, idx) => {\n          const schemaItem: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Fallback, idx);\n          return computeDefaults<T, S, F>(validator, schemaItem, {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            parentDefaults: item,\n            required,\n          });\n        }) as T[];\n      }\n\n      // Deeply inject defaults into already existing form data\n      if (Array.isArray(rawFormData)) {\n        const schemaItem: S = getInnerSchemaForArrayItem<S>(schema);\n        defaults = rawFormData.map((item: T, idx: number) => {\n          return computeDefaults<T, S, F>(validator, schemaItem, {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            rawFormData: item,\n            parentDefaults: get(defaults, [idx]),\n            required,\n          });\n        }) as T[];\n      }\n\n      const ignoreMinItemsFlagSet = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === 'requiredOnly';\n      if (ignoreMinItemsFlagSet && !required) {\n        // If no form data exists or defaults are set leave the field empty/non-existent, otherwise\n        // return form data/defaults\n        return defaults ? defaults : undefined;\n      }\n\n      const defaultsLength = Array.isArray(defaults) ? defaults.length : 0;\n      if (\n        !schema.minItems ||\n        isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\n        schema.minItems <= defaultsLength\n      ) {\n        return defaults ? defaults : [];\n      }\n\n      const defaultEntries: T[] = (defaults || []) as T[];\n      const fillerSchema: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Invert);\n      const fillerDefault = fillerSchema.default;\n\n      // Calculate filler entries for remaining items (minItems - existing raw data/defaults)\n      const fillerEntries: T[] = new Array(schema.minItems - defaultsLength).fill(\n        computeDefaults<any, S, F>(validator, fillerSchema, {\n          parentDefaults: fillerDefault,\n          rootSchema,\n          _recurseList,\n          experimental_defaultFormStateBehavior,\n          required,\n        })\n      ) as T[];\n      // then fill up the rest with either the item default or empty, up to minItems\n      return defaultEntries.concat(fillerEntries);\n    }\n  }\n\n  return defaults;\n}\n\n/** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n * computed to have defaults provided in the `schema`.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the default state is desired\n * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport default function getDefaultFormState<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  theSchema: S,\n  formData?: T,\n  rootSchema?: S,\n  includeUndefinedValues: boolean | 'excludeObjectChildren' = false,\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior\n) {\n  if (!isObject(theSchema)) {\n    throw new Error('Invalid schema: ' + theSchema);\n  }\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, formData);\n  const defaults = computeDefaults<T, S, F>(validator, schema, {\n    rootSchema,\n    includeUndefinedValues,\n    experimental_defaultFormStateBehavior,\n    rawFormData: formData,\n  });\n  if (formData === undefined || formData === null || (typeof formData === 'number' && isNaN(formData))) {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n  const { mergeExtraDefaults } = experimental_defaultFormStateBehavior?.arrayMinItems || {};\n  if (isObject(formData)) {\n    return mergeDefaultsWithFormData<T>(defaults as T, formData, mergeExtraDefaults);\n  }\n  if (Array.isArray(formData)) {\n    return mergeDefaultsWithFormData<T[]>(defaults as T[], formData, mergeExtraDefaults);\n  }\n  return formData;\n}\n","import getUiOptions from './getUiOptions';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\n\n/** Checks to see if the `uiSchema` contains the `widget` field and that the widget is not `hidden`\n *\n * @param uiSchema - The UI Schema from which to detect if it is customized\n * @returns - True if the `uiSchema` describes a custom widget, false otherwise\n */\nexport default function isCustomWidget<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(uiSchema: UiSchema<T, S, F> = {}) {\n  return (\n    // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.\n    // https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets\n    'widget' in getUiOptions<T, S, F>(uiSchema) && getUiOptions<T, S, F>(uiSchema)['widget'] !== 'hidden'\n  );\n}\n","import { UI_WIDGET_KEY } from '../constants';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\n\n/** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which check for array of files flag is desired\n * @param [uiSchema={}] - The UI schema from which to check the widget\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema/uiSchema contains an array of files, otherwise false\n */\nexport default function isFilesArray<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  uiSchema: UiSchema<T, S, F> = {},\n  rootSchema?: S\n) {\n  if (uiSchema[UI_WIDGET_KEY] === 'files') {\n    return true;\n  }\n  if (schema.items) {\n    const itemsSchema = retrieveSchema<T, S, F>(validator, schema.items as S, rootSchema);\n    return itemsSchema.type === 'string' && itemsSchema.format === 'data-url';\n  }\n  return false;\n}\n","import { UI_FIELD_KEY, UI_WIDGET_KEY } from '../constants';\nimport getSchemaType from '../getSchemaType';\nimport getUiOptions from '../getUiOptions';\nimport isCustomWidget from '../isCustomWidget';\nimport {\n  FormContextType,\n  GlobalUISchemaOptions,\n  RJSFSchema,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidatorType,\n} from '../types';\nimport isFilesArray from './isFilesArray';\nimport isMultiSelect from './isMultiSelect';\n\n/** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n * should be displayed in a UI.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the display label flag is desired\n * @param [uiSchema={}] - The UI schema from which to derive potentially displayable information\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n * @returns - True if the label should be displayed or false if it should not\n */\nexport default function getDisplayLabel<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  uiSchema: UiSchema<T, S, F> = {},\n  rootSchema?: S,\n  globalOptions?: GlobalUISchemaOptions\n): boolean {\n  const uiOptions = getUiOptions<T, S, F>(uiSchema, globalOptions);\n  const { label = true } = uiOptions;\n  let displayLabel = !!label;\n  const schemaType = getSchemaType<S>(schema);\n\n  if (schemaType === 'array') {\n    displayLabel =\n      isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\n      isFilesArray<T, S, F>(validator, schema, uiSchema, rootSchema) ||\n      isCustomWidget(uiSchema);\n  }\n\n  if (schemaType === 'object') {\n    displayLabel = false;\n  }\n  if (schemaType === 'boolean' && !uiSchema[UI_WIDGET_KEY]) {\n    displayLabel = false;\n  }\n  if (uiSchema[UI_FIELD_KEY]) {\n    displayLabel = false;\n  }\n  return displayLabel;\n}\n","import isEmpty from 'lodash/isEmpty';\n\nimport mergeObjects from '../mergeObjects';\nimport { ErrorSchema, FormContextType, RJSFSchema, StrictRJSFSchema, ValidationData, ValidatorType } from '../types';\n\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n * `validator.toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\n * `validationData` is returned.\n *\n * @param validator - The validator used to convert an ErrorSchema to a list of errors\n * @param validationData - The current `ValidationData` into which to merge the additional errors\n * @param [additionalErrorSchema] - The additional set of errors in an `ErrorSchema`\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\n *        removed in the next major release.\n */\nexport default function mergeValidationData<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  validationData: ValidationData<T>,\n  additionalErrorSchema?: ErrorSchema<T>\n): ValidationData<T> {\n  if (!additionalErrorSchema) {\n    return validationData;\n  }\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\n  let errors = validator.toErrorList(additionalErrorSchema);\n  let errorSchema = additionalErrorSchema;\n  if (!isEmpty(oldErrorSchema)) {\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\n    errors = [...oldErrors].concat(errors);\n  }\n  return { errorSchema, errors };\n}\n","import get from 'lodash/get';\nimport has from 'lodash/has';\n\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport { PROPERTIES_KEY, REF_KEY } from '../constants';\nimport retrieveSchema from './retrieveSchema';\n\nconst NO_VALUE = Symbol('no Value');\n\n/** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the new\n * schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the nature\n * of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the old schema\n * that are non-existent in the new schema are set to `undefined`. The data sanitization process has the following flow:\n *\n * - If the new schema is an object that contains a `properties` object then:\n *   - Create a `removeOldSchemaData` object, setting each key in the `oldSchema.properties` having `data` to undefined\n *   - Create an empty `nestedData` object for use in the key filtering below:\n *   - Iterate over each key in the `newSchema.properties` as follows:\n *     - Get the `formValue` of the key from the `data`\n *     - Get the `oldKeySchema` and `newKeyedSchema` for the key, defaulting to `{}` when it doesn't exist\n *     - Retrieve the schema for any refs within each `oldKeySchema` and/or `newKeySchema`\n *     - Get the types of the old and new keyed schemas and if the old doesn't exist or the old & new are the same then:\n *       - If `removeOldSchemaData` has an entry for the key, delete it since the new schema has the same property\n *       - If type of the key in the new schema is `object`:\n *         - Store the value from the recursive `sanitizeDataForNewSchema` call in `nestedData[key]`\n *       - Otherwise, check for default or const values:\n *         - Get the old and new `default` values from the schema and check:\n *           - If the new `default` value does not match the form value:\n *             - If the old `default` value DOES match the form value, then:\n *               - Replace `removeOldSchemaData[key]` with the new `default`\n *               - Otherwise, if the new schema is `readOnly` then replace `removeOldSchemaData[key]` with undefined\n *         - Get the old and new `const` values from the schema and check:\n *           - If the new `const` value does not match the form value:\n *           - If the old `const` value DOES match the form value, then:\n *             - Replace `removeOldSchemaData[key]` with the new `const`\n *             - Otherwise, replace `removeOldSchemaData[key]` with undefined\n *   - Once all keys have been processed, return an object built as follows:\n *     - `{ ...removeOldSchemaData, ...nestedData, ...pick(data, keysToKeep) }`\n * - If the new and old schema types are array and the `data` is an array then:\n *   - If the type of the old and new schema `items` are a non-array objects:\n *     - Retrieve the schema for any refs within each `oldKeySchema.items` and/or `newKeySchema.items`\n *     - If the `type`s of both items are the same (or the old does not have a type):\n *       - If the type is \"object\", then:\n *         - For each element in the `data` recursively sanitize the data, stopping at `maxItems` if specified\n *       - Otherwise, just return the `data` removing any values after `maxItems` if it is set\n *   - If the type of the old and new schema `items` are booleans of the same value, return `data` as is\n * - Otherwise return `undefined`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param [newSchema] - The new schema for which the data is being sanitized\n * @param [oldSchema] - The old schema from which the data originated\n * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n * @returns - The new form data, with all the fields uniquely associated with the old schema set\n *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n */\nexport default function sanitizeDataForNewSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, rootSchema: S, newSchema?: S, oldSchema?: S, data: any = {}): T {\n  // By default, we will clear the form data\n  let newFormData;\n  // If the new schema is of type object and that object contains a list of properties\n  if (has(newSchema, PROPERTIES_KEY)) {\n    // Create an object containing root-level keys in the old schema, setting each key to undefined to remove the data\n    const removeOldSchemaData: GenericObjectType = {};\n    if (has(oldSchema, PROPERTIES_KEY)) {\n      const properties = get(oldSchema, PROPERTIES_KEY, {});\n      Object.keys(properties).forEach((key) => {\n        if (has(data, key)) {\n          removeOldSchemaData[key] = undefined;\n        }\n      });\n    }\n    const keys: string[] = Object.keys(get(newSchema, PROPERTIES_KEY, {}));\n    // Create a place to store nested data that will be a side-effect of the filter\n    const nestedData: GenericObjectType = {};\n    keys.forEach((key) => {\n      const formValue = get(data, key);\n      let oldKeyedSchema: S = get(oldSchema, [PROPERTIES_KEY, key], {});\n      let newKeyedSchema: S = get(newSchema, [PROPERTIES_KEY, key], {});\n      // Resolve the refs if they exist\n      if (has(oldKeyedSchema, REF_KEY)) {\n        oldKeyedSchema = retrieveSchema<T, S, F>(validator, oldKeyedSchema, rootSchema, formValue);\n      }\n      if (has(newKeyedSchema, REF_KEY)) {\n        newKeyedSchema = retrieveSchema<T, S, F>(validator, newKeyedSchema, rootSchema, formValue);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaTypeForKey = get(oldKeyedSchema, 'type');\n      const newSchemaTypeForKey = get(newKeyedSchema, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaTypeForKey || oldSchemaTypeForKey === newSchemaTypeForKey) {\n        if (has(removeOldSchemaData, key)) {\n          // SIDE-EFFECT: remove the undefined value for a key that has the same type between the old and new schemas\n          delete removeOldSchemaData[key];\n        }\n        // If it is an object, we'll recurse and store the resulting sanitized data for the key\n        if (newSchemaTypeForKey === 'object' || (newSchemaTypeForKey === 'array' && Array.isArray(formValue))) {\n          // SIDE-EFFECT: process the new schema type of object recursively to save iterations\n          const itemData = sanitizeDataForNewSchema<T, S, F>(\n            validator,\n            rootSchema,\n            newKeyedSchema,\n            oldKeyedSchema,\n            formValue\n          );\n          if (itemData !== undefined || newSchemaTypeForKey === 'array') {\n            // only put undefined values for the array type and not the object type\n            nestedData[key] = itemData;\n          }\n        } else {\n          // Ok, the non-object types match, let's make sure that a default or a const of a different value is replaced\n          // with the new default or const. This allows the case where two schemas differ that only by the default/const\n          // value to be properly selected\n          const newOptionDefault = get(newKeyedSchema, 'default', NO_VALUE);\n          const oldOptionDefault = get(oldKeyedSchema, 'default', NO_VALUE);\n          if (newOptionDefault !== NO_VALUE && newOptionDefault !== formValue) {\n            if (oldOptionDefault === formValue) {\n              // If the old default matches the formValue, we'll update the new value to match the new default\n              removeOldSchemaData[key] = newOptionDefault;\n            } else if (get(newKeyedSchema, 'readOnly') === true) {\n              // If the new schema has the default set to read-only, treat it like a const and remove the value\n              removeOldSchemaData[key] = undefined;\n            }\n          }\n\n          const newOptionConst = get(newKeyedSchema, 'const', NO_VALUE);\n          const oldOptionConst = get(oldKeyedSchema, 'const', NO_VALUE);\n          if (newOptionConst !== NO_VALUE && newOptionConst !== formValue) {\n            // Since this is a const, if the old value matches, replace the value with the new const otherwise clear it\n            removeOldSchemaData[key] = oldOptionConst === formValue ? newOptionConst : undefined;\n          }\n        }\n      }\n    });\n\n    newFormData = {\n      ...data,\n      ...removeOldSchemaData,\n      ...nestedData,\n    };\n    // First apply removing the old schema data, then apply the nested data, then apply the old data keys to keep\n  } else if (get(oldSchema, 'type') === 'array' && get(newSchema, 'type') === 'array' && Array.isArray(data)) {\n    let oldSchemaItems = get(oldSchema, 'items');\n    let newSchemaItems = get(newSchema, 'items');\n    // If any of the array types `items` are arrays (remember arrays are objects) then we'll just drop the data\n    // Eventually, we may want to deal with when either of the `items` are arrays since those tuple validations\n    if (\n      typeof oldSchemaItems === 'object' &&\n      typeof newSchemaItems === 'object' &&\n      !Array.isArray(oldSchemaItems) &&\n      !Array.isArray(newSchemaItems)\n    ) {\n      if (has(oldSchemaItems, REF_KEY)) {\n        oldSchemaItems = retrieveSchema<T, S, F>(validator, oldSchemaItems as S, rootSchema, data as T);\n      }\n      if (has(newSchemaItems, REF_KEY)) {\n        newSchemaItems = retrieveSchema<T, S, F>(validator, newSchemaItems as S, rootSchema, data as T);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaType = get(oldSchemaItems, 'type');\n      const newSchemaType = get(newSchemaItems, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaType || oldSchemaType === newSchemaType) {\n        const maxItems = get(newSchema, 'maxItems', -1);\n        if (newSchemaType === 'object') {\n          newFormData = data.reduce((newValue, aValue) => {\n            const itemValue = sanitizeDataForNewSchema<T, S, F>(\n              validator,\n              rootSchema,\n              newSchemaItems as S,\n              oldSchemaItems as S,\n              aValue\n            );\n            if (itemValue !== undefined && (maxItems < 0 || newValue.length < maxItems)) {\n              newValue.push(itemValue);\n            }\n            return newValue;\n          }, []);\n        } else {\n          newFormData = maxItems > 0 && data.length > maxItems ? data.slice(0, maxItems) : data;\n        }\n      }\n    } else if (\n      typeof oldSchemaItems === 'boolean' &&\n      typeof newSchemaItems === 'boolean' &&\n      oldSchemaItems === newSchemaItems\n    ) {\n      // If they are both booleans and have the same value just return the data as is otherwise fall-thru to undefined\n      newFormData = data;\n    }\n    // Also probably want to deal with `prefixItems` as tuples with the latest 2020 draft\n  }\n  return newFormData as T;\n}\n","import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\n\nimport { ALL_OF_KEY, DEPENDENCIES_KEY, ID_KEY, ITEMS_KEY, PROPERTIES_KEY, REF_KEY } from '../constants';\nimport isObject from '../isObject';\nimport { FormContextType, IdSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\nimport getSchemaType from '../getSchemaType';\n\n/** An internal helper that generates an `IdSchema` object for the `schema`, recursively with protection against\n * infinite recursion\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `IdSchema` is desired\n * @param idPrefix - The prefix to use for the id\n * @param idSeparator - The separator to use for the path segments in the id\n * @param [id] - The base id for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\n * @returns - The `IdSchema` object for the `schema`\n */\nfunction toIdSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  idPrefix: string,\n  idSeparator: string,\n  id?: string | null,\n  rootSchema?: S,\n  formData?: T,\n  _recurseList: S[] = []\n): IdSchema<T> {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\n    if (sameSchemaIndex === -1) {\n      return toIdSchemaInternal<T, S, F>(\n        validator,\n        _schema,\n        idPrefix,\n        idSeparator,\n        id,\n        rootSchema,\n        formData,\n        _recurseList.concat(_schema)\n      );\n    }\n  }\n  if (ITEMS_KEY in schema && !get(schema, [ITEMS_KEY, REF_KEY])) {\n    return toIdSchemaInternal<T, S, F>(\n      validator,\n      get(schema, ITEMS_KEY) as S,\n      idPrefix,\n      idSeparator,\n      id,\n      rootSchema,\n      formData,\n      _recurseList\n    );\n  }\n  const $id = id || idPrefix;\n  const idSchema: IdSchema = { $id } as IdSchema<T>;\n  if (getSchemaType<S>(schema) === 'object' && PROPERTIES_KEY in schema) {\n    for (const name in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, name]);\n      const fieldId = idSchema[ID_KEY] + idSeparator + name;\n      idSchema[name] = toIdSchemaInternal<T, S, F>(\n        validator,\n        isObject(field) ? field : {},\n        idPrefix,\n        idSeparator,\n        fieldId,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        get(formData, [name]),\n        _recurseList\n      );\n    }\n  }\n  return idSchema as IdSchema<T>;\n}\n\n/** Generates an `IdSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `IdSchema` is desired\n * @param [id] - The base id for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [idPrefix='root'] - The prefix to use for the id\n * @param [idSeparator='_'] - The separator to use for the path segments in the id\n * @returns - The `IdSchema` object for the `schema`\n */\nexport default function toIdSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  id?: string | null,\n  rootSchema?: S,\n  formData?: T,\n  idPrefix = 'root',\n  idSeparator = '_'\n): IdSchema<T> {\n  return toIdSchemaInternal<T, S, F>(validator, schema, idPrefix, idSeparator, id, rootSchema, formData);\n}\n","import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport set from 'lodash/set';\n\nimport {\n  ALL_OF_KEY,\n  ANY_OF_KEY,\n  ADDITIONAL_PROPERTIES_KEY,\n  DEPENDENCIES_KEY,\n  ITEMS_KEY,\n  NAME_KEY,\n  ONE_OF_KEY,\n  PROPERTIES_KEY,\n  REF_KEY,\n  RJSF_ADDITONAL_PROPERTIES_FLAG,\n} from '../constants';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport { FormContextType, PathSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getClosestMatchingOption from './getClosestMatchingOption';\nimport retrieveSchema from './retrieveSchema';\n\n/** An internal helper that generates an `PathSchema` object for the `schema`, recursively with protection against\n * infinite recursion\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\n * @returns - The `PathSchema` object for the `schema`\n */\nfunction toPathSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  name: string,\n  rootSchema?: S,\n  formData?: T,\n  _recurseList: S[] = []\n): PathSchema<T> {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\n    if (sameSchemaIndex === -1) {\n      return toPathSchemaInternal<T, S, F>(\n        validator,\n        _schema,\n        name,\n        rootSchema,\n        formData,\n        _recurseList.concat(_schema)\n      );\n    }\n  }\n\n  let pathSchema: PathSchema = {\n    [NAME_KEY]: name.replace(/^\\./, ''),\n  } as PathSchema;\n\n  if (ONE_OF_KEY in schema || ANY_OF_KEY in schema) {\n    const xxxOf: S[] = ONE_OF_KEY in schema ? (schema.oneOf as S[]) : (schema.anyOf as S[]);\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    const index = getClosestMatchingOption<T, S, F>(validator, rootSchema!, formData, xxxOf, 0, discriminator);\n    const _schema: S = xxxOf![index] as S;\n    pathSchema = {\n      ...pathSchema,\n      ...toPathSchemaInternal<T, S, F>(validator, _schema, name, rootSchema, formData, _recurseList),\n    };\n  }\n\n  if (ADDITIONAL_PROPERTIES_KEY in schema && schema[ADDITIONAL_PROPERTIES_KEY] !== false) {\n    set(pathSchema, RJSF_ADDITONAL_PROPERTIES_FLAG, true);\n  }\n\n  if (ITEMS_KEY in schema && Array.isArray(formData)) {\n    formData.forEach((element, i: number) => {\n      pathSchema[i] = toPathSchemaInternal<T, S, F>(\n        validator,\n        schema.items as S,\n        `${name}.${i}`,\n        rootSchema,\n        element,\n        _recurseList\n      );\n    });\n  } else if (PROPERTIES_KEY in schema) {\n    for (const property in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, property]);\n      pathSchema[property] = toPathSchemaInternal<T, S, F>(\n        validator,\n        field,\n        `${name}.${property}`,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        get(formData, [property]),\n        _recurseList\n      );\n    }\n  }\n  return pathSchema as PathSchema<T>;\n}\n\n/** Generates an `PathSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The `PathSchema` object for the `schema`\n */\nexport default function toPathSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  name = '',\n  rootSchema?: S,\n  formData?: T\n): PathSchema<T> {\n  return toPathSchemaInternal(validator, schema, name, rootSchema, formData);\n}\n","import deepEquals from './deepEquals';\nimport {\n  ErrorSchema,\n  Experimental_DefaultFormStateBehavior,\n  FormContextType,\n  GlobalUISchemaOptions,\n  IdSchema,\n  PathSchema,\n  RJSFSchema,\n  SchemaUtilsType,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n} from './types';\nimport {\n  getDefaultFormState,\n  getDisplayLabel,\n  getClosestMatchingOption,\n  getFirstMatchingOption,\n  getMatchingOption,\n  isFilesArray,\n  isMultiSelect,\n  isSelect,\n  mergeValidationData,\n  retrieveSchema,\n  sanitizeDataForNewSchema,\n  toIdSchema,\n  toPathSchema,\n} from './schema';\n\n/** The `SchemaUtils` class provides a wrapper around the publicly exported APIs in the `utils/schema` directory such\n * that one does not have to explicitly pass the `validator`, `rootSchema`, or `experimental_defaultFormStateBehavior` to each method.\n * Since these generally do not change across a `Form`, this allows for providing a simplified set of APIs to the\n * `@rjsf/core` components and the various themes as well. This class implements the `SchemaUtilsType` interface.\n */\nclass SchemaUtils<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  implements SchemaUtilsType<T, S, F>\n{\n  rootSchema: S;\n  validator: ValidatorType<T, S, F>;\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior;\n\n  /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n   * @param rootSchema - The root schema that will be forwarded to all the APIs\n   * @param experimental_defaultFormStateBehavior - Configuration flags to allow users to override default form state behavior\n   */\n  constructor(\n    validator: ValidatorType<T, S, F>,\n    rootSchema: S,\n    experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior\n  ) {\n    this.rootSchema = rootSchema;\n    this.validator = validator;\n    this.experimental_defaultFormStateBehavior = experimental_defaultFormStateBehavior;\n  }\n\n  /** Returns the `ValidatorType` in the `SchemaUtilsType`\n   *\n   * @returns - The `ValidatorType`\n   */\n  getValidator() {\n    return this.validator;\n  }\n\n  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of\n   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation\n   * of a new `SchemaUtilsType` with incomplete properties.\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one\n   * @param rootSchema - The root schema that will be compared against the current one\n   * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`\n   */\n  doesSchemaUtilsDiffer(\n    validator: ValidatorType<T, S, F>,\n    rootSchema: S,\n    experimental_defaultFormStateBehavior = {}\n  ): boolean {\n    if (!validator || !rootSchema) {\n      return false;\n    }\n    return (\n      this.validator !== validator ||\n      !deepEquals(this.rootSchema, rootSchema) ||\n      !deepEquals(this.experimental_defaultFormStateBehavior, experimental_defaultFormStateBehavior)\n    );\n  }\n\n  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n   * computed to have defaults provided in the `schema`.\n   *\n   * @param schema - The schema for which the default state is desired\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n   *          If \"excludeObjectChildren\", pass `includeUndefinedValues` as false when computing defaults for any nested\n   *          object properties.\n   * @returns - The resulting `formData` with all the defaults provided\n   */\n  getDefaultFormState(\n    schema: S,\n    formData?: T,\n    includeUndefinedValues: boolean | 'excludeObjectChildren' = false\n  ): T | T[] | undefined {\n    return getDefaultFormState<T, S, F>(\n      this.validator,\n      schema,\n      formData,\n      this.rootSchema,\n      includeUndefinedValues,\n      this.experimental_defaultFormStateBehavior\n    );\n  }\n\n  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n   * should be displayed in a UI.\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [uiSchema] - The UI schema from which to derive potentially displayable information\n   * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n   * @returns - True if the label should be displayed or false if it should not\n   */\n  getDisplayLabel(schema: S, uiSchema?: UiSchema<T, S, F>, globalOptions?: GlobalUISchemaOptions) {\n    return getDisplayLabel<T, S, F>(this.validator, schema, uiSchema, this.rootSchema, globalOptions);\n  }\n\n  /** Determines which of the given `options` provided most closely matches the `formData`.\n   * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.\n   *\n   * The closest match is determined using the number of matching properties, and more heavily favors options with\n   * matching readOnly, default, or const values.\n   *\n   * @param formData - The form data associated with the schema\n   * @param options - The list of options that can be selected from\n   * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n   */\n  getClosestMatchingOption(\n    formData: T | undefined,\n    options: S[],\n    selectedOption?: number,\n    discriminatorField?: string\n  ): number {\n    return getClosestMatchingOption<T, S, F>(\n      this.validator,\n      this.rootSchema,\n      formData,\n      options,\n      selectedOption,\n      discriminatorField\n    );\n  }\n\n  /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\n   * Always returns the first option if there is nothing that matches.\n   *\n   * @param formData - The current formData, if any, used to figure out a match\n   * @param options - The list of options to find a matching options from\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The firstindex of the matched option or 0 if none is available\n   */\n  getFirstMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string): number {\n    return getFirstMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\n  }\n\n  /** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n   * Deprecated, use `getFirstMatchingOption()` instead.\n   *\n   * @param formData - The current formData, if any, onto which to provide any missing defaults\n   * @param options - The list of options to find a matching options from\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The index of the matched option or 0 if none is available\n   * @deprecated\n   */\n  getMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string) {\n    return getMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\n  }\n\n  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n   *\n   * @param schema - The schema for which check for array of files flag is desired\n   * @param [uiSchema] - The UI schema from which to check the widget\n   * @returns - True if schema/uiSchema contains an array of files, otherwise false\n   */\n  isFilesArray(schema: S, uiSchema?: UiSchema<T, S, F>) {\n    return isFilesArray<T, S, F>(this.validator, schema, uiSchema, this.rootSchema);\n  }\n\n  /** Checks to see if the `schema` combination represents a multi-select\n   *\n   * @param schema - The schema for which check for a multi-select flag is desired\n   * @returns - True if schema contains a multi-select, otherwise false\n   */\n  isMultiSelect(schema: S) {\n    return isMultiSelect<T, S, F>(this.validator, schema, this.rootSchema);\n  }\n\n  /** Checks to see if the `schema` combination represents a select\n   *\n   * @param schema - The schema for which check for a select flag is desired\n   * @returns - True if schema contains a select, otherwise false\n   */\n  isSelect(schema: S) {\n    return isSelect<T, S, F>(this.validator, schema, this.rootSchema);\n  }\n\n  /** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in\n   * the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n   * `getValidator().toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed,\n   * then `validationData` is returned.\n   *\n   * @param validationData - The current `ValidationData` into which to merge the additional errors\n   * @param [additionalErrorSchema] - The additional set of errors\n   * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n   * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\n   *        removed in the next major release.\n   */\n  mergeValidationData(validationData: ValidationData<T>, additionalErrorSchema?: ErrorSchema<T>): ValidationData<T> {\n    return mergeValidationData<T, S, F>(this.validator, validationData, additionalErrorSchema);\n  }\n\n  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and\n   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially\n   * recursive resolution.\n   *\n   * @param schema - The schema for which retrieving a schema is desired\n   * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n   * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n   */\n  retrieveSchema(schema: S, rawFormData?: T) {\n    return retrieveSchema<T, S, F>(this.validator, schema, this.rootSchema, rawFormData);\n  }\n\n  /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the\n   * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the\n   * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the\n   * old schemas that are non-existent in the new schema are set to `undefined`.\n   *\n   * @param [newSchema] - The new schema for which the data is being sanitized\n   * @param [oldSchema] - The old schema from which the data originated\n   * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n   * @returns - The new form data, with all the fields uniquely associated with the old schema set\n   *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n   */\n  sanitizeDataForNewSchema(newSchema?: S, oldSchema?: S, data?: any): T {\n    return sanitizeDataForNewSchema(this.validator, this.rootSchema, newSchema, oldSchema, data);\n  }\n\n  /** Generates an `IdSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [id] - The base id for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [idPrefix='root'] - The prefix to use for the id\n   * @param [idSeparator='_'] - The separator to use for the path segments in the id\n   * @returns - The `IdSchema` object for the `schema`\n   */\n  toIdSchema(schema: S, id?: string | null, formData?: T, idPrefix = 'root', idSeparator = '_'): IdSchema<T> {\n    return toIdSchema<T, S, F>(this.validator, schema, id, this.rootSchema, formData, idPrefix, idSeparator);\n  }\n\n  /** Generates an `PathSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [name] - The base name for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @returns - The `PathSchema` object for the `schema`\n   */\n  toPathSchema(schema: S, name?: string, formData?: T): PathSchema<T> {\n    return toPathSchema<T, S, F>(this.validator, schema, name, this.rootSchema, formData);\n  }\n}\n\n/** Creates a `SchemaUtilsType` interface that is based around the given `validator` and `rootSchema` parameters. The\n * resulting interface implementation will forward the `validator` and `rootSchema` to all the wrapped APIs.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @returns - An implementation of a `SchemaUtilsType` interface\n */\nexport default function createSchemaUtils<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  experimental_defaultFormStateBehavior = {}\n): SchemaUtilsType<T, S, F> {\n  return new SchemaUtils<T, S, F>(validator, rootSchema, experimental_defaultFormStateBehavior);\n}\n","/** Given the `FileReader.readAsDataURL()` based `dataURI` extracts that data into an actual Blob along with the name\n * of that Blob if provided in the URL. If no name is provided, then the name falls back to `unknown`.\n *\n * @param dataURI - The `DataUrl` potentially containing name and raw data to be converted to a Blob\n * @returns - an object containing a Blob and its name, extracted from the URI\n */\nexport default function dataURItoBlob(dataURI: string) {\n  // Split metadata from data\n  const splitted: string[] = dataURI.split(',');\n  // Split params\n  const params: string[] = splitted[0].split(';');\n  // Get mime-type from params\n  const type: string = params[0].replace('data:', '');\n  // Filter the name property from params\n  const properties = params.filter((param) => {\n    return param.split('=')[0] === 'name';\n  });\n  // Look for the name and use unknown if no name property.\n  let name: string;\n  if (properties.length !== 1) {\n    name = 'unknown';\n  } else {\n    // Because we filtered out the other property,\n    // we only have the name case here, which we decode to make it human-readable\n    name = decodeURI(properties[0].split('=')[1]);\n  }\n\n  // Built the Uint8Array Blob parameter from the base64 string.\n  try {\n    const binary = atob(splitted[1]);\n    const array = [];\n    for (let i = 0; i < binary.length; i++) {\n      array.push(binary.charCodeAt(i));\n    }\n    // Create the blob object\n    const blob = new window.Blob([new Uint8Array(array)], { type });\n\n    return { blob, name };\n  } catch (error) {\n    return { blob: { size: 0, type: (error as Error).message }, name: dataURI };\n  }\n}\n","/** Potentially substitutes all replaceable parameters with the associated value(s) from the `params` if available. When\n * a `params` array is provided, each value in the array is used to replace any of the replaceable parameters in the\n * `inputString` using the `%1`, `%2`, etc. replacement specifiers.\n *\n * @param inputString - The string which will be potentially updated with replacement parameters\n * @param params - The optional list of replaceable parameter values to substitute into the english string\n * @returns - The updated string with any replacement specifiers replaced\n */\nexport default function replaceStringParameters(inputString: string, params?: string[]) {\n  let output = inputString;\n  if (Array.isArray(params)) {\n    const parts = output.split(/(%\\d)/);\n    params.forEach((param, index) => {\n      const partIndex = parts.findIndex((part) => part === `%${index + 1}`);\n      if (partIndex >= 0) {\n        parts[partIndex] = param;\n      }\n    });\n    output = parts.join('');\n  }\n  return output;\n}\n","import { TranslatableString } from './enums';\nimport replaceStringParameters from './replaceStringParameters';\n\n/** Translates a `TranslatableString` value `stringToTranslate` into english. When a `params` array is provided, each\n * value in the array is used to replace any of the replaceable parameters in the `stringToTranslate` using the `%1`,\n * `%2`, etc. replacement specifiers.\n *\n * @param stringToTranslate - The `TranslatableString` value to convert to english\n * @param params - The optional list of replaceable parameter values to substitute into the english string\n * @returns - The `stringToTranslate` itself with any replaceable parameter values substituted\n */\nexport default function englishStringTranslator(stringToTranslate: TranslatableString, params?: string[]): string {\n  return replaceStringParameters(stringToTranslate, params);\n}\n","import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Returns the value(s) from `allEnumOptions` at the index(es) provided by `valueIndex`. If `valueIndex` is not an\n * array AND the index is not valid for `allEnumOptions`, `emptyValue` is returned. If `valueIndex` is an array, AND it\n * contains an invalid index, the returned array will have the resulting undefined values filtered out, leaving only\n * valid values or in the worst case, an empty array.\n *\n * @param valueIndex - The index(es) of the value(s) that should be returned\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @param [emptyValue] - The value to return when the non-array `valueIndex` does not refer to a real option\n * @returns - The single or list of values specified by the single or list of indexes if they are valid. Otherwise,\n *        `emptyValue` or an empty list.\n */\nexport default function enumOptionsValueForIndex<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number | Array<string | number>,\n  allEnumOptions: EnumOptionsType<S>[] = [],\n  emptyValue?: EnumOptionsType<S>['value']\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\n  if (Array.isArray(valueIndex)) {\n    return valueIndex.map((index) => enumOptionsValueForIndex(index, allEnumOptions)).filter((val) => val);\n  }\n  // So Number(null) and Number('') both return 0, so use emptyValue for those two values\n  const index = valueIndex === '' || valueIndex === null ? -1 : Number(valueIndex);\n  const option = allEnumOptions[index];\n  return option ? option.value : emptyValue;\n}\n","import isEqual from 'lodash/isEqual';\n\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\n\n/** Removes the enum option value at the `valueIndex` from the currently `selected` (list of) value(s). If `selected` is\n * a list, then that list is updated to remove the enum option value with the `valueIndex` in `allEnumOptions`. If it is\n * a single value, then if the enum option value with the `valueIndex` in `allEnumOptions` matches `selected`, undefined\n * is returned, otherwise the `selected` value is returned.\n *\n * @param valueIndex - The index of the value to be removed from the selected list or single value\n * @param selected - The current (list of) selected value(s)\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @returns - The updated `selected` with the enum option value at `valueIndex` in `allEnumOptions` removed from it,\n *        unless `selected` is a single value. In that case, if the `valueIndex` value matches `selected`, returns\n *        undefined, otherwise `selected`.\n */\nexport default function enumOptionsDeselectValue<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number,\n  selected?: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = []\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\n  if (Array.isArray(selected)) {\n    return selected.filter((v) => !isEqual(v, value));\n  }\n  return isEqual(value, selected) ? undefined : selected;\n}\n","import isEqual from 'lodash/isEqual';\n\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Determines whether the given `value` is (one of) the `selected` value(s).\n *\n * @param value - The value being checked to see if it is selected\n * @param selected - The current selected value or list of values\n * @returns - true if the `value` is one of the `selected` ones, false otherwise\n */\nexport default function enumOptionsIsSelected<S extends StrictRJSFSchema = RJSFSchema>(\n  value: EnumOptionsType<S>['value'],\n  selected: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][]\n) {\n  if (Array.isArray(selected)) {\n    return selected.some((sel) => isEqual(sel, value));\n  }\n  return isEqual(selected, value);\n}\n","import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsIsSelected from './enumOptionsIsSelected';\n\n/** Returns the index(es) of the options in `allEnumOptions` whose value(s) match the ones in `value`. All the\n * `enumOptions` are filtered based on whether they are a \"selected\" `value` and the index of each selected one is then\n * stored in an array. If `multiple` is true, that array is returned, otherwise the first element in the array is\n * returned.\n *\n * @param value - The single value or list of values for which indexes are desired\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @param [multiple=false] - Optional flag, if true will return a list of index, otherwise a single one\n * @returns - A single string index for the first `value` in `allEnumOptions`, if not `multiple`. Otherwise, the list\n *        of indexes for (each of) the value(s) in `value`.\n */\nexport default function enumOptionsIndexForValue<S extends StrictRJSFSchema = RJSFSchema>(\n  value: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = [],\n  multiple = false\n): string | string[] | undefined {\n  const selectedIndexes: string[] = allEnumOptions\n    .map((opt, index) => (enumOptionsIsSelected(opt.value, value) ? String(index) : undefined))\n    .filter((opt) => typeof opt !== 'undefined') as string[];\n  if (!multiple) {\n    return selectedIndexes[0];\n  }\n  return selectedIndexes;\n}\n","import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\nimport { isNil } from 'lodash';\n\n/** Add the enum option value at the `valueIndex` to the list of `selected` values in the proper order as defined by\n * `allEnumOptions`\n *\n * @param valueIndex - The index of the value that should be selected\n * @param selected - The current list of selected values\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @returns - The updated list of selected enum values with enum value at the `valueIndex` added to it\n */\nexport default function enumOptionsSelectValue<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number,\n  selected: EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = []\n) {\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\n  if (!isNil(value)) {\n    const index = allEnumOptions.findIndex((opt) => value === opt.value);\n    const all = allEnumOptions.map(({ value: val }) => val);\n    const updated = selected.slice(0, index).concat(value, selected.slice(index));\n    // As inserting values at predefined index positions doesn't work with empty\n    // arrays, we need to reorder the updated selection to match the initial order\n    return updated.sort((a, b) => Number(all.indexOf(a) > all.indexOf(b)));\n  }\n  return selected;\n}\n","import cloneDeep from 'lodash/cloneDeep';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\n\nimport { ErrorSchema } from './types';\nimport { ERRORS_KEY } from './constants';\n\n/** The `ErrorSchemaBuilder<T>` is used to build an `ErrorSchema<T>` since the definition of the `ErrorSchema` type is\n * designed for reading information rather than writing it. Use this class to add, replace or clear errors in an error\n * schema by using either dotted path or an array of path names. Once you are done building the `ErrorSchema`, you can\n * get the result and/or reset all the errors back to an initial set and start again.\n */\nexport default class ErrorSchemaBuilder<T = any> {\n  /** The error schema being built\n   *\n   * @private\n   */\n  private errorSchema: ErrorSchema<T> = {};\n\n  /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.\n   *\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\n   */\n  constructor(initialSchema?: ErrorSchema<T>) {\n    this.resetAllErrors(initialSchema);\n  }\n\n  /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`\n   */\n  get ErrorSchema() {\n    return this.errorSchema;\n  }\n\n  /** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.\n   *\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\n   * @returns - The error block for the given `pathOfError` or the root if not provided\n   * @private\n   */\n  private getOrCreateErrorBlock(pathOfError?: string | string[]) {\n    const hasPath = (Array.isArray(pathOfError) && pathOfError.length > 0) || typeof pathOfError === 'string';\n    let errorBlock: ErrorSchema = hasPath ? get(this.errorSchema, pathOfError) : this.errorSchema;\n    if (!errorBlock && pathOfError) {\n      errorBlock = {};\n      set(this.errorSchema, pathOfError, errorBlock);\n    }\n    return errorBlock;\n  }\n\n  /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.\n   *\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  resetAllErrors(initialSchema?: ErrorSchema<T>) {\n    this.errorSchema = initialSchema ? cloneDeep(initialSchema) : {};\n    return this;\n  }\n\n  /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within\n   * the schema described by the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param errorOrList - The error or list of errors to add into the `ErrorSchema`\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  addErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    let errorsList = get(errorBlock, ERRORS_KEY);\n    if (!Array.isArray(errorsList)) {\n      errorsList = [];\n      errorBlock[ERRORS_KEY] = errorsList;\n    }\n\n    if (Array.isArray(errorOrList)) {\n      errorsList.push(...errorOrList);\n    } else {\n      errorsList.push(errorOrList);\n    }\n    return this;\n  }\n\n  /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location\n   * within the schema described by the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param errorOrList - The error or list of errors to set into the `ErrorSchema`\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  setErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    // Effectively clone the array being given to prevent accidental outside manipulation of the given list\n    const listToAdd = Array.isArray(errorOrList) ? [...errorOrList] : [errorOrList];\n    set(errorBlock, ERRORS_KEY, listToAdd);\n    return this;\n  }\n\n  /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by\n   * the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  clearErrors(pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    set(errorBlock, ERRORS_KEY, []);\n    return this;\n  }\n}\n","import { RangeSpecType, StrictRJSFSchema } from './types';\nimport { RJSFSchema } from './types';\n\n/** Extracts the range spec information `{ step?: number, min?: number, max?: number }` that can be spread onto an HTML\n * input from the range analog in the schema `{ multipleOf?: number, minimum?: number, maximum?: number }`.\n *\n * @param schema - The schema from which to extract the range spec\n * @returns - A range specification from the schema\n */\nexport default function rangeSpec<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  const spec: RangeSpecType = {};\n  if (schema.multipleOf) {\n    spec.step = schema.multipleOf;\n  }\n  if (schema.minimum || schema.minimum === 0) {\n    spec.min = schema.minimum;\n  }\n  if (schema.maximum || schema.maximum === 0) {\n    spec.max = schema.maximum;\n  }\n  return spec;\n}\n","import rangeSpec from './rangeSpec';\nimport { FormContextType, InputPropsType, RJSFSchema, StrictRJSFSchema, UIOptionsType } from './types';\n\n/** Using the `schema`, `defaultType` and `options`, extract out the props for the <input> element that make sense.\n *\n * @param schema - The schema for the field provided by the widget\n * @param [defaultType] - The default type, if any, for the field provided by the widget\n * @param [options={}] - The UI Options for the field provided by the widget\n * @param [autoDefaultStepAny=true] - Determines whether to auto-default step=any when the type is number and no step\n * @returns - The extracted `InputPropsType` object\n */\nexport default function getInputProps<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  schema: RJSFSchema,\n  defaultType?: string,\n  options: UIOptionsType<T, S, F> = {},\n  autoDefaultStepAny = true\n): InputPropsType {\n  const inputProps: InputPropsType = {\n    type: defaultType || 'text',\n    ...rangeSpec(schema),\n  };\n\n  // If options.inputType is set use that as the input type\n  if (options.inputType) {\n    inputProps.type = options.inputType;\n  } else if (!defaultType) {\n    // If the schema is of type number or integer, set the input type to number\n    if (schema.type === 'number') {\n      inputProps.type = 'number';\n      // Only add step if one isn't already defined and we are auto-defaulting the \"any\" step\n      if (autoDefaultStepAny && inputProps.step === undefined) {\n        // Setting step to 'any' fixes a bug in Safari where decimals are not\n        // allowed in number inputs\n        inputProps.step = 'any';\n      }\n    } else if (schema.type === 'integer') {\n      inputProps.type = 'number';\n      // Only add step if one isn't already defined\n      if (inputProps.step === undefined) {\n        // Since this is integer, you always want to step up or down in multiples of 1\n        inputProps.step = 1;\n      }\n    }\n  }\n\n  if (options.autocomplete) {\n    inputProps.autoComplete = options.autocomplete;\n  }\n\n  return inputProps;\n}\n","import { SUBMIT_BTN_OPTIONS_KEY } from './constants';\nimport getUiOptions from './getUiOptions';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, UISchemaSubmitButtonOptions } from './types';\n\n/** The default submit button options, exported for testing purposes\n */\nexport const DEFAULT_OPTIONS: UISchemaSubmitButtonOptions = {\n  props: {\n    disabled: false,\n  },\n  submitText: 'Submit',\n  norender: false,\n};\n\n/** Extracts any `ui:submitButtonOptions` from the `uiSchema` and merges them onto the `DEFAULT_OPTIONS`\n *\n * @param [uiSchema={}] - the UI Schema from which to extract submit button props\n * @returns - The merging of the `DEFAULT_OPTIONS` with any custom ones\n */\nexport default function getSubmitButtonOptions<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(uiSchema: UiSchema<T, S, F> = {}): UISchemaSubmitButtonOptions {\n  const uiOptions = getUiOptions<T, S, F>(uiSchema);\n  if (uiOptions && uiOptions[SUBMIT_BTN_OPTIONS_KEY]) {\n    const options = uiOptions[SUBMIT_BTN_OPTIONS_KEY] as UISchemaSubmitButtonOptions;\n    return { ...DEFAULT_OPTIONS, ...options };\n  }\n\n  return DEFAULT_OPTIONS;\n}\n","import { FormContextType, TemplatesType, Registry, UIOptionsType, StrictRJSFSchema, RJSFSchema } from './types';\n\n/** Returns the template with the given `name` from either the `uiSchema` if it is defined or from the `registry`\n * otherwise. NOTE, since `ButtonTemplates` are not overridden in `uiSchema` only those in the `registry` are returned.\n *\n * @param name - The name of the template to fetch, restricted to the keys of `TemplatesType`\n * @param registry - The `Registry` from which to read the template\n * @param [uiOptions={}] - The `UIOptionsType` from which to read an alternate template\n * @returns - The template from either the `uiSchema` or `registry` for the `name`\n */\nexport default function getTemplate<\n  Name extends keyof TemplatesType<T, S, F>,\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(name: Name, registry: Registry<T, S, F>, uiOptions: UIOptionsType<T, S, F> = {}): TemplatesType<T, S, F>[Name] {\n  const { templates } = registry;\n  if (name === 'ButtonTemplates') {\n    return templates[name];\n  }\n  return (\n    // Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent\n    // To avoid that, we cast uiOptions to `any` before accessing the name field\n    ((uiOptions as any)[name] as TemplatesType<T, S, F>[Name]) || templates[name]\n  );\n}\n","import { createElement } from 'react';\nimport ReactIs from 'react-is';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\n\nimport { FormContextType, RJSFSchema, Widget, RegistryWidgetsType, StrictRJSFSchema } from './types';\nimport getSchemaType from './getSchemaType';\n\n/** The map of schema types to widget type to widget name\n */\nconst widgetMap: { [k: string]: { [j: string]: string } } = {\n  boolean: {\n    checkbox: 'CheckboxWidget',\n    radio: 'RadioWidget',\n    select: 'SelectWidget',\n    hidden: 'HiddenWidget',\n  },\n  string: {\n    text: 'TextWidget',\n    password: 'PasswordWidget',\n    email: 'EmailWidget',\n    hostname: 'TextWidget',\n    ipv4: 'TextWidget',\n    ipv6: 'TextWidget',\n    uri: 'URLWidget',\n    'data-url': 'FileWidget',\n    radio: 'RadioWidget',\n    select: 'SelectWidget',\n    textarea: 'TextareaWidget',\n    hidden: 'HiddenWidget',\n    date: 'DateWidget',\n    datetime: 'DateTimeWidget',\n    'date-time': 'DateTimeWidget',\n    'alt-date': 'AltDateWidget',\n    'alt-datetime': 'AltDateTimeWidget',\n    time: 'TimeWidget',\n    color: 'ColorWidget',\n    file: 'FileWidget',\n  },\n  number: {\n    text: 'TextWidget',\n    select: 'SelectWidget',\n    updown: 'UpDownWidget',\n    range: 'RangeWidget',\n    radio: 'RadioWidget',\n    hidden: 'HiddenWidget',\n  },\n  integer: {\n    text: 'TextWidget',\n    select: 'SelectWidget',\n    updown: 'UpDownWidget',\n    range: 'RangeWidget',\n    radio: 'RadioWidget',\n    hidden: 'HiddenWidget',\n  },\n  array: {\n    select: 'SelectWidget',\n    checkboxes: 'CheckboxesWidget',\n    files: 'FileWidget',\n    hidden: 'HiddenWidget',\n  },\n};\n\n/** Wraps the given widget with stateless functional component that will merge any `defaultProps.options` with the\n * `options` that are provided in the props. It will add the wrapper component as a `MergedWidget` property onto the\n * `Widget` so that future attempts to wrap `AWidget` will return the already existing wrapper.\n *\n * @param AWidget - A widget that will be wrapped or one that is already wrapped\n * @returns - The wrapper widget\n */\nfunction mergeWidgetOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  AWidget: Widget<T, S, F>\n) {\n  let MergedWidget: Widget<T, S, F> | undefined = get(AWidget, 'MergedWidget');\n  // cache return value as property of widget for proper react reconciliation\n  if (!MergedWidget) {\n    const defaultOptions = (AWidget.defaultProps && AWidget.defaultProps.options) || {};\n    MergedWidget = ({ options, ...props }) => {\n      return <AWidget options={{ ...defaultOptions, ...options }} {...props} />;\n    };\n    set(AWidget, 'MergedWidget', MergedWidget);\n  }\n  return MergedWidget;\n}\n\n/** Given a schema representing a field to render and either the name or actual `Widget` implementation, returns the\n * React component that is used to render the widget. If the `widget` is already a React component, then it is wrapped\n * with a `MergedWidget`. Otherwise an attempt is made to look up the widget inside of the `registeredWidgets` map based\n * on the schema type and `widget` name. If no widget component can be found an `Error` is thrown.\n *\n * @param schema - The schema for the field\n * @param [widget] - Either the name of the widget OR a `Widget` implementation to use\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\n * @returns - The `Widget` component to use\n * @throws - An error if there is no `Widget` component that can be returned\n */\nexport default function getWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  widget?: Widget<T, S, F> | string,\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\n): Widget<T, S, F> {\n  const type = getSchemaType(schema);\n\n  if (\n    typeof widget === 'function' ||\n    (widget && ReactIs.isForwardRef(createElement(widget))) ||\n    ReactIs.isMemo(widget)\n  ) {\n    return mergeWidgetOptions<T, S, F>(widget as Widget<T, S, F>);\n  }\n\n  if (typeof widget !== 'string') {\n    throw new Error(`Unsupported widget definition: ${typeof widget}`);\n  }\n\n  if (widget in registeredWidgets) {\n    const registeredWidget = registeredWidgets[widget];\n    return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\n  }\n\n  if (typeof type === 'string') {\n    if (!(type in widgetMap)) {\n      throw new Error(`No widget for type '${type}'`);\n    }\n\n    if (widget in widgetMap[type]) {\n      const registeredWidget = registeredWidgets[widgetMap[type][widget]];\n      return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\n    }\n  }\n\n  throw new Error(`No widget '${widget}' for type '${type}'`);\n}\n","import { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** JS has no built-in hashing function, so rolling our own\n *  based on Java's hashing fn:\n *  http://www.java2s.com/example/nodejs-utility-method/string-hash/hashcode-4dc2b.html\n *\n * @param string - The string for which to get the hash\n * @returns - The resulting hash of the string in hex format\n */\nfunction hashString(string: string): string {\n  let hash = 0;\n  for (let i = 0; i < string.length; i += 1) {\n    const chr = string.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  return hash.toString(16);\n}\n\n/** Stringifies the schema and returns the hash of the resulting string. Sorts schema fields\n * in consistent order before stringify to prevent different hash ids for the same schema.\n *\n * @param schema - The schema for which the hash is desired\n * @returns - The string obtained from the hash of the stringified schema\n */\nexport default function hashForSchema<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  const allKeys = new Set<string>();\n  // solution source: https://stackoverflow.com/questions/16167581/sort-object-properties-and-json-stringify/53593328#53593328\n  JSON.stringify(schema, (key, value) => (allKeys.add(key), value));\n  return hashString(JSON.stringify(schema, Array.from(allKeys).sort()));\n}\n","import getWidget from './getWidget';\nimport { FormContextType, RegistryWidgetsType, RJSFSchema, StrictRJSFSchema, Widget } from './types';\n\n/** Detects whether the `widget` exists for the `schema` with the associated `registryWidgets` and returns true if it\n * does, or false if it doesn't.\n *\n * @param schema - The schema for the field\n * @param widget - Either the name of the widget OR a `Widget` implementation to use\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\n * @returns - True if the widget exists, false otherwise\n */\nexport default function hasWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  widget: Widget<T, S, F> | string,\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\n) {\n  try {\n    getWidget(schema, widget, registeredWidgets);\n    return true;\n  } catch (e) {\n    const err: Error = e as Error;\n    if (err.message && (err.message.startsWith('No widget') || err.message.startsWith('Unsupported widget'))) {\n      return false;\n    }\n    throw e;\n  }\n}\n","import isString from 'lodash/isString';\n\nimport { IdSchema } from './types';\nimport { ID_KEY } from './constants';\n\n/** Generates a consistent `id` pattern for a given `id` and a `suffix`\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @param suffix - The suffix to append to the id\n */\nfunction idGenerator<T = any>(id: IdSchema<T> | string, suffix: string) {\n  const theId = isString(id) ? id : id[ID_KEY];\n  return `${theId}__${suffix}`;\n}\n/** Return a consistent `id` for the field description element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field description element from the given `id`\n */\nexport function descriptionId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'description');\n}\n\n/** Return a consistent `id` for the field error element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field error element from the given `id`\n */\nexport function errorId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'error');\n}\n\n/** Return a consistent `id` for the field examples element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field examples element from the given `id`\n */\nexport function examplesId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'examples');\n}\n\n/** Return a consistent `id` for the field help element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field help element from the given `id`\n */\nexport function helpId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'help');\n}\n\n/** Return a consistent `id` for the field title element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field title element from the given `id`\n */\nexport function titleId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'title');\n}\n\n/** Return a list of element ids that contain additional information about the field that can be used to as the aria\n * description of the field. This is correctly omitting `titleId` which would be \"labeling\" rather than \"describing\" the\n * element.\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @param [includeExamples=false] - Optional flag, if true, will add the `examplesId` into the list\n * @returns - The string containing the list of ids for use in an `aria-describedBy` attribute\n */\nexport function ariaDescribedByIds<T = any>(id: IdSchema<T> | string, includeExamples = false) {\n  const examples = includeExamples ? ` ${examplesId<T>(id)}` : '';\n  return `${errorId<T>(id)} ${descriptionId<T>(id)} ${helpId<T>(id)}${examples}`;\n}\n\n/** Return a consistent `id` for the `optionIndex`s of a `Radio` or `Checkboxes` widget\n *\n * @param id - The id of the parent component for the option\n * @param optionIndex - The index of the option for which the id is desired\n * @returns - An id for the option index based on the parent `id`\n */\nexport function optionId(id: string, optionIndex: number) {\n  return `${id}-${optionIndex}`;\n}\n","import { ReactElement } from 'react';\n\n/** Helper function that will return the value to use for a widget `label` based on `hideLabel`. The `fallback` is used\n * as the return value from the function when `hideLabel` is true. Due to the implementation of theme components, it\n * may be necessary to return something other than `undefined` to cause the theme component to not render a label. Some\n * themes require may `false` and others may require an empty string.\n *\n * @param [label] - The label string or component to render when not hidden\n * @param [hideLabel] - Flag, if true, will cause the label to be hidden\n * @param [fallback] - One of 3 values, `undefined` (the default), `false` or an empty string\n * @returns - `fallback` if `hideLabel` is true, otherwise `label`\n */\nexport function labelValue(label?: string | ReactElement, hideLabel?: boolean, fallback?: ''): undefined | string;\nexport default function labelValue(label?: string | ReactElement, hideLabel?: boolean, fallback?: false | '') {\n  return hideLabel ? fallback : label;\n}\n","/** Converts a local Date string into a UTC date string\n *\n * @param dateString - The string representation of a date as accepted by the `Date()` constructor\n * @returns - A UTC date string if `dateString` is truthy, otherwise undefined\n */\nexport default function localToUTC(dateString: string) {\n  return dateString ? new Date(dateString).toJSON() : undefined;\n}\n","import { CONST_KEY, ENUM_KEY } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Returns the constant value from the schema when it is either a single value enum or has a const key. Otherwise\n * throws an error.\n *\n * @param schema - The schema from which to obtain the constant value\n * @returns - The constant value for the schema\n * @throws - Error when the schema does not have a constant value\n */\nexport default function toConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  if (ENUM_KEY in schema && Array.isArray(schema.enum) && schema.enum.length === 1) {\n    return schema.enum[0];\n  }\n  if (CONST_KEY in schema) {\n    return schema.const;\n  }\n  throw new Error('schema cannot be inferred as a constant');\n}\n","import toConstant from './toConstant';\nimport { RJSFSchema, EnumOptionsType, StrictRJSFSchema } from './types';\n\n/** Gets the list of options from the schema. If the schema has an enum list, then those enum values are returned. The\n * labels for the options will be extracted from the non-standard, RJSF-deprecated `enumNames` if it exists, otherwise\n * the label will be the same as the `value`. If the schema has a `oneOf` or `anyOf`, then the value is the list of\n * `const` values from the schema and the label is either the `schema.title` or the value.\n *\n * @param schema - The schema from which to extract the options list\n * @returns - The list of options from the schema\n */\nexport default function optionsList<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S\n): EnumOptionsType<S>[] | undefined {\n  // enumNames was deprecated in v5 and is intentionally omitted from the RJSFSchema type.\n  // Cast the type to include enumNames so the feature still works.\n  const schemaWithEnumNames = schema as S & { enumNames?: string[] };\n  if (schemaWithEnumNames.enumNames && process.env.NODE_ENV !== 'production') {\n    console.warn('The enumNames property is deprecated and may be removed in a future major release.');\n  }\n  if (schema.enum) {\n    return schema.enum.map((value, i) => {\n      const label = (schemaWithEnumNames.enumNames && schemaWithEnumNames.enumNames[i]) || String(value);\n      return { label, value };\n    });\n  }\n  const altSchemas = schema.oneOf || schema.anyOf;\n  return (\n    altSchemas &&\n    altSchemas.map((aSchemaDef) => {\n      const aSchema = aSchemaDef as S;\n      const value = toConstant(aSchema);\n      const label = aSchema.title || String(value);\n      return {\n        schema: aSchema,\n        label,\n        value,\n      };\n    })\n  );\n}\n","import { GenericObjectType } from './types';\n\n/** Given a list of `properties` and an `order` list, returns a list that contains the `properties` ordered correctly.\n * If `order` is not an array, then the untouched `properties` list is returned. Otherwise `properties` is ordered per\n * the `order` list. If `order` contains a '*' then any `properties` that are not mentioned explicity in `order` will be\n * places in the location of the `*`.\n *\n * @param properties - The list of property keys to be ordered\n * @param order - An array of property keys to be ordered first, with an optional '*' property\n * @returns - A list with the `properties` ordered\n * @throws - Error when the properties cannot be ordered correctly\n */\nexport default function orderProperties(properties: string[], order?: string[]): string[] {\n  if (!Array.isArray(order)) {\n    return properties;\n  }\n\n  const arrayToHash = (arr: string[]) =>\n    arr.reduce((prev: GenericObjectType, curr) => {\n      prev[curr] = true;\n      return prev;\n    }, {});\n  const errorPropList = (arr: string[]) =>\n    arr.length > 1 ? `properties '${arr.join(\"', '\")}'` : `property '${arr[0]}'`;\n  const propertyHash = arrayToHash(properties);\n  const orderFiltered = order.filter((prop) => prop === '*' || propertyHash[prop]);\n  const orderHash = arrayToHash(orderFiltered);\n\n  const rest = properties.filter((prop: string) => !orderHash[prop]);\n  const restIndex = orderFiltered.indexOf('*');\n  if (restIndex === -1) {\n    if (rest.length) {\n      throw new Error(`uiSchema order list does not contain ${errorPropList(rest)}`);\n    }\n    return orderFiltered;\n  }\n  if (restIndex !== orderFiltered.lastIndexOf('*')) {\n    throw new Error('uiSchema order list contains more than one wildcard item');\n  }\n\n  const complete = [...orderFiltered];\n  complete.splice(restIndex, 1, ...rest);\n  return complete;\n}\n","/** Returns a string representation of the `num` that is padded with leading \"0\"s if necessary\n *\n * @param num - The number to pad\n * @param width - The width of the string at which no lead padding is necessary\n * @returns - The number converted to a string with leading zero padding if the number of digits is less than `width`\n */\nexport default function pad(num: number, width: number) {\n  let s = String(num);\n  while (s.length < width) {\n    s = '0' + s;\n  }\n  return s;\n}\n","import { DateObject } from './types';\n\n/** Parses the `dateString` into a `DateObject`, including the time information when `includeTime` is true\n *\n * @param dateString - The date string to parse into a DateObject\n * @param [includeTime=true] - Optional flag, if false, will not include the time data into the object\n * @returns - The date string converted to a `DateObject`\n * @throws - Error when the date cannot be parsed from the string\n */\nexport default function parseDateString(dateString?: string, includeTime = true): DateObject {\n  if (!dateString) {\n    return {\n      year: -1,\n      month: -1,\n      day: -1,\n      hour: includeTime ? -1 : 0,\n      minute: includeTime ? -1 : 0,\n      second: includeTime ? -1 : 0,\n    };\n  }\n  const date = new Date(dateString);\n  if (Number.isNaN(date.getTime())) {\n    throw new Error('Unable to parse date ' + dateString);\n  }\n  return {\n    year: date.getUTCFullYear(),\n    month: date.getUTCMonth() + 1, // oh you, javascript.\n    day: date.getUTCDate(),\n    hour: includeTime ? date.getUTCHours() : 0,\n    minute: includeTime ? date.getUTCMinutes() : 0,\n    second: includeTime ? date.getUTCSeconds() : 0,\n  };\n}\n","import { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Check to see if a `schema` specifies that a value must be true. This happens when:\n * - `schema.const` is truthy\n * - `schema.enum` == `[true]`\n * - `schema.anyOf` or `schema.oneOf` has a single value which recursively returns true\n * - `schema.allOf` has at least one value which recursively returns true\n *\n * @param schema - The schema to check\n * @returns - True if the schema specifies a value that must be true, false otherwise\n */\nexport default function schemaRequiresTrueValue<S extends StrictRJSFSchema = RJSFSchema>(schema: S): boolean {\n  // Check if const is a truthy value\n  if (schema.const) {\n    return true;\n  }\n\n  // Check if an enum has a single value of true\n  if (schema.enum && schema.enum.length === 1 && schema.enum[0] === true) {\n    return true;\n  }\n\n  // If anyOf has a single value, evaluate the subschema\n  if (schema.anyOf && schema.anyOf.length === 1) {\n    return schemaRequiresTrueValue(schema.anyOf[0] as S);\n  }\n\n  // If oneOf has a single value, evaluate the subschema\n  if (schema.oneOf && schema.oneOf.length === 1) {\n    return schemaRequiresTrueValue(schema.oneOf[0] as S);\n  }\n\n  // Evaluate each subschema in allOf, to see if one of them requires a true value\n  if (schema.allOf) {\n    const schemaSome = (subSchema: S['additionalProperties']) => schemaRequiresTrueValue(subSchema as S);\n    return schema.allOf.some(schemaSome);\n  }\n\n  return false;\n}\n","import React from 'react';\n\nimport deepEquals from './deepEquals';\n\n/** Determines whether the given `component` should be rerendered by comparing its current set of props and state\n * against the next set. If either of those two sets are not the same, then the component should be rerendered.\n *\n * @param component - A React component being checked\n * @param nextProps - The next set of props against which to check\n * @param nextState - The next set of state against which to check\n * @returns - True if the component should be re-rendered, false otherwise\n */\nexport default function shouldRender(component: React.Component, nextProps: any, nextState: any) {\n  const { props, state } = component;\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\n}\n","import { DateObject } from './types';\n\n/** Returns a UTC date string for the given `dateObject`. If `time` is false, then the time portion of the string is\n * removed.\n *\n * @param dateObject - The `DateObject` to convert to a date string\n * @param [time=true] - Optional flag used to remove the time portion of the date string if false\n * @returns - The UTC date string\n */\nexport default function toDateString(dateObject: DateObject, time = true) {\n  const { year, month, day, hour = 0, minute = 0, second = 0 } = dateObject;\n  const utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\n  const datetime = new Date(utcTime).toJSON();\n  return time ? datetime : datetime.slice(0, 10);\n}\n","import isPlainObject from 'lodash/isPlainObject';\n\nimport { ERRORS_KEY } from './constants';\nimport { ErrorSchema, GenericObjectType, RJSFValidationError } from './types';\n\n/** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n *\n * @param errorSchema - The `ErrorSchema` instance to convert\n * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n * @returns - The list of `RJSFValidationErrors` extracted from the `errorSchema`\n */\nexport default function toErrorList<T = any>(\n  errorSchema?: ErrorSchema<T>,\n  fieldPath: string[] = []\n): RJSFValidationError[] {\n  if (!errorSchema) {\n    return [];\n  }\n  let errorList: RJSFValidationError[] = [];\n  if (ERRORS_KEY in errorSchema) {\n    errorList = errorList.concat(\n      errorSchema[ERRORS_KEY]!.map((message: string) => {\n        const property = `.${fieldPath.join('.')}`;\n        return {\n          property,\n          message,\n          stack: `${property} ${message}`,\n        };\n      })\n    );\n  }\n  return Object.keys(errorSchema).reduce((acc, key) => {\n    if (key !== ERRORS_KEY) {\n      const childSchema = (errorSchema as GenericObjectType)[key];\n      if (isPlainObject(childSchema)) {\n        acc = acc.concat(toErrorList(childSchema, [...fieldPath, key]));\n      }\n    }\n    return acc;\n  }, errorList);\n}\n","import toPath from 'lodash/toPath';\n\nimport { ErrorSchema, RJSFValidationError } from './types';\nimport ErrorSchemaBuilder from './ErrorSchemaBuilder';\n\n/** Transforms a rjsf validation errors list:\n * [\n *   {property: '.level1.level2[2].level3', message: 'err a'},\n *   {property: '.level1.level2[2].level3', message: 'err b'},\n *   {property: '.level1.level2[4].level3', message: 'err b'},\n * ]\n * Into an error tree:\n * {\n *   level1: {\n *     level2: {\n *       2: {level3: {errors: ['err a', 'err b']}},\n *       4: {level3: {errors: ['err b']}},\n *     }\n *   }\n * };\n *\n * @param errors - The list of RJSFValidationError objects\n * @returns - The `ErrorSchema` built from the list of `RJSFValidationErrors`\n */\nexport default function toErrorSchema<T = any>(errors: RJSFValidationError[]): ErrorSchema<T> {\n  const builder = new ErrorSchemaBuilder<T>();\n  if (errors.length) {\n    errors.forEach((error) => {\n      const { property, message } = error;\n      // When the property is the root element, just use an empty array for the path\n      const path = property === '.' ? [] : toPath(property);\n      // If the property is at the root (.level1) then toPath creates\n      // an empty array element at the first index. Remove it.\n      if (path.length > 0 && path[0] === '') {\n        path.splice(0, 1);\n      }\n      if (message) {\n        builder.addErrors(message, path);\n      }\n    });\n  }\n  return builder.ErrorSchema;\n}\n","import isPlainObject from 'lodash/isPlainObject';\n\nimport { ErrorSchema, FormValidation, GenericObjectType } from './types';\n\n/** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError()` functions from it\n *\n * @param errorHandler - The `FormValidation` error handling structure\n * @returns - The `ErrorSchema` resulting from the stripping of the `addError()` function\n */\nexport default function unwrapErrorHandler<T = any>(errorHandler: FormValidation<T>): ErrorSchema<T> {\n  return Object.keys(errorHandler).reduce((acc, key) => {\n    if (key === 'addError') {\n      return acc;\n    } else {\n      const childSchema = (errorHandler as GenericObjectType)[key];\n      if (isPlainObject(childSchema)) {\n        return {\n          ...acc,\n          [key]: unwrapErrorHandler(childSchema),\n        };\n      }\n      return { ...acc, [key]: childSchema };\n    }\n  }, {} as ErrorSchema<T>);\n}\n","import pad from './pad';\n\n/** Converts a UTC date string into a local Date format\n *\n * @param jsonDate - A UTC date string\n * @returns - An empty string when `jsonDate` is falsey, otherwise a date string in local format\n */\nexport default function utcToLocal(jsonDate: string) {\n  if (!jsonDate) {\n    return '';\n  }\n\n  // required format of `'yyyy-MM-ddThh:mm' followed by optional ':ss' or ':ss.SSS'\n  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)\n  // > should be a _valid local date and time string_ (not GMT)\n\n  // Note - date constructor passed local ISO-8601 does not correctly\n  // change time to UTC in node pre-8\n  const date = new Date(jsonDate);\n\n  const yyyy = pad(date.getFullYear(), 4);\n  const MM = pad(date.getMonth() + 1, 2);\n  const dd = pad(date.getDate(), 2);\n  const hh = pad(date.getHours(), 2);\n  const mm = pad(date.getMinutes(), 2);\n  const ss = pad(date.getSeconds(), 2);\n  const SSS = pad(date.getMilliseconds(), 3);\n\n  return `${yyyy}-${MM}-${dd}T${hh}:${mm}:${ss}.${SSS}`;\n}\n","import isEmpty from 'lodash/isEmpty';\n\nimport mergeObjects from './mergeObjects';\nimport toErrorList from './toErrorList';\nimport { ErrorSchema, ValidationData } from './types';\n\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n * `toErrorList()` on the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\n * `validationData` is returned.\n *\n * @param validationData - The current `ValidationData` into which to merge the additional errors\n * @param [additionalErrorSchema] - The optional additional set of errors in an `ErrorSchema`\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n */\nexport default function validationDataMerge<T = any>(\n  validationData: ValidationData<T>,\n  additionalErrorSchema?: ErrorSchema<T>\n): ValidationData<T> {\n  if (!additionalErrorSchema) {\n    return validationData;\n  }\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\n  let errors = toErrorList(additionalErrorSchema);\n  let errorSchema = additionalErrorSchema;\n  if (!isEmpty(oldErrorSchema)) {\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\n    errors = [...oldErrors].concat(errors);\n  }\n  return { errorSchema, errors };\n}\n","import { REF_KEY, ROOT_SCHEMA_PREFIX } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\nimport isObject from 'lodash/isObject';\n\n/** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\n * `withIdRefPrefix` for any other elements.\n *\n * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n */\nfunction withIdRefPrefixObject<S extends StrictRJSFSchema = RJSFSchema>(node: S): S {\n  for (const key in node) {\n    const realObj: { [k: string]: any } = node;\n    const value = realObj[key];\n    if (key === REF_KEY && typeof value === 'string' && value.startsWith('#')) {\n      realObj[key] = ROOT_SCHEMA_PREFIX + value;\n    } else {\n      realObj[key] = withIdRefPrefix<S>(value);\n    }\n  }\n  return node;\n}\n\n/** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\n * `withIdRefPrefix` for any other elements.\n *\n * @param node - The list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n */\nfunction withIdRefPrefixArray<S extends StrictRJSFSchema = RJSFSchema>(node: S[]): S[] {\n  for (let i = 0; i < node.length; i++) {\n    node[i] = withIdRefPrefix<S>(node[i]) as S;\n  }\n  return node;\n}\n\n/** Recursively prefixes all `$ref`s in a schema with the value of the `ROOT_SCHEMA_PREFIX` constant.\n * This is used in isValid to make references to the rootSchema\n *\n * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n * @returns - A copy of the `schemaNode` with updated `$ref`s\n */\nexport default function withIdRefPrefix<S extends StrictRJSFSchema = RJSFSchema>(schemaNode: S): S | S[] {\n  if (Array.isArray(schemaNode)) {\n    return withIdRefPrefixArray<S>([...schemaNode]);\n  }\n  if (isObject(schemaNode)) {\n    return withIdRefPrefixObject<S>({ ...schemaNode });\n  }\n  return schemaNode;\n}\n","/** An enumeration of all the translatable strings used by `@rjsf/core` and its themes. The value of each of the\n * enumeration keys is expected to be the actual english string. Some strings contain replaceable parameter values\n * as indicated by `%1`, `%2`, etc. The number after the `%` indicates the order of the parameter. The ordering of\n * parameters is important because some languages may choose to put the second parameter before the first in its\n * translation. Also, some strings are rendered using `markdown-to-jsx` and thus support markdown and inline html.\n */\nexport enum TranslatableString {\n  /** Fallback title of an array item, used by ArrayField */\n  ArrayItemTitle = 'Item',\n  /** Missing items reason, used by ArrayField */\n  MissingItems = 'Missing items definition',\n  /** Yes label, used by BooleanField */\n  YesLabel = 'Yes',\n  /** No label, used by BooleanField */\n  NoLabel = 'No',\n  /** Close label, used by ErrorList */\n  CloseLabel = 'Close',\n  /** Errors label, used by ErrorList */\n  ErrorsLabel = 'Errors',\n  /** New additionalProperties string default value, used by ObjectField */\n  NewStringDefault = 'New Value',\n  /** Add button title, used by AddButton */\n  AddButton = 'Add',\n  /** Add button title, used by AddButton */\n  AddItemButton = 'Add Item',\n  /** Copy button title, used by IconButton */\n  CopyButton = 'Copy',\n  /** Move down button title, used by IconButton */\n  MoveDownButton = 'Move down',\n  /** Move up button title, used by IconButton */\n  MoveUpButton = 'Move up',\n  /** Remove button title, used by IconButton */\n  RemoveButton = 'Remove',\n  /** Now label, used by AltDateWidget */\n  NowLabel = 'Now',\n  /** Clear label, used by AltDateWidget */\n  ClearLabel = 'Clear',\n  /** Aria date label, used by DateWidget */\n  AriaDateLabel = 'Select a date',\n  /** File preview label, used by FileWidget */\n  PreviewLabel = 'Preview',\n  /** Decrement button aria label, used by UpDownWidget */\n  DecrementAriaLabel = 'Decrease value by 1',\n  /** Increment button aria label, used by UpDownWidget */\n  IncrementAriaLabel = 'Increase value by 1',\n  // Strings with replaceable parameters\n  /** Unknown field type reason, where %1 will be replaced with the type as provided by SchemaField */\n  UnknownFieldType = 'Unknown field type %1',\n  /** Option prefix, where %1 will be replaced with the option index as provided by MultiSchemaField */\n  OptionPrefix = 'Option %1',\n  /** Option prefix, where %1 and %2 will be replaced by the schema title and option index, respectively as provided by\n   * MultiSchemaField\n   */\n  TitleOptionPrefix = '%1 option %2',\n  /** Key label, where %1 will be replaced by the label as provided by WrapIfAdditionalTemplate */\n  KeyLabel = '%1 Key',\n  // Strings with replaceable parameters AND/OR that support markdown and html\n  /** Invalid object field configuration as provided by the ObjectField */\n  InvalidObjectField = 'Invalid \"%1\" object field configuration: <em>%2</em>.',\n  /** Unsupported field schema, used by UnsupportedField */\n  UnsupportedField = 'Unsupported field schema.',\n  /** Unsupported field schema, where %1 will be replaced by the idSchema.$id as provided by UnsupportedField */\n  UnsupportedFieldWithId = 'Unsupported field schema for field <code>%1</code>.',\n  /** Unsupported field schema, where %1 will be replaced by the reason string as provided by UnsupportedField */\n  UnsupportedFieldWithReason = 'Unsupported field schema: <em>%1</em>.',\n  /** Unsupported field schema, where %1 and %2 will be replaced by the idSchema.$id and reason strings, respectively,\n   * as provided by UnsupportedField\n   */\n  UnsupportedFieldWithIdAndReason = 'Unsupported field schema for field <code>%1</code>: <em>%2</em>.',\n  /** File name, type and size info, where %1, %2 and %3 will be replaced by the file name, file type and file size as\n   * provided by FileWidget\n   */\n  FilesInfo = '<strong>%1</strong> (%2, %3 bytes)',\n}\n","import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\n\nimport { ID_KEY } from '../constants';\nimport hashForSchema from '../hashForSchema';\nimport {\n  CustomValidator,\n  ErrorSchema,\n  ErrorTransformer,\n  FormContextType,\n  RJSFSchema,\n  RJSFValidationError,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n} from '../types';\n\n/** The type of the map of schema hash to schema\n */\nexport type SchemaMap<S extends StrictRJSFSchema = RJSFSchema> = {\n  [hash: string]: S;\n};\n\n/** An implementation of the `ValidatorType` interface that is designed for use in capturing schemas used by the\n * `isValid()` function. The rest of the implementation of the interface throws errors when it is attempted to be used.\n * An instance of the object allows the caller to capture the schemas used in calls to the `isValid()` function. These\n * captured schema, along with the root schema used to construct the object are stored in the map of schemas keyed by\n * the hashed value of the schema. NOTE: After hashing the schema, an $id with the hash value is added to the\n * schema IF that schema doesn't already have an $id, prior to putting the schema into the map.\n */\nexport default class ParserValidator<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  implements ValidatorType<T, S, F>\n{\n  /** The rootSchema provided during construction of the class */\n  readonly rootSchema: S;\n\n  /** The map of schemas encountered by the ParserValidator */\n  schemaMap: SchemaMap<S> = {};\n\n  /** Construct the ParserValidator for the given `rootSchema`. This `rootSchema` will be stashed in the `schemaMap`\n   * first.\n   *\n   * @param rootSchema - The root schema against which this validator will be executed\n   */\n  constructor(rootSchema: S) {\n    this.rootSchema = rootSchema;\n    this.addSchema(rootSchema, hashForSchema<S>(rootSchema));\n  }\n\n  /** Adds the given `schema` to the `schemaMap` keyed by the `hash` or `ID_KEY` if present on the `schema`. If the\n   * schema does not have an `ID_KEY`, then the `hash` will be added as the `ID_KEY` to allow the schema to be\n   * associated with it's `hash` for future use (by a schema compiler).\n   *\n   * @param schema - The schema which is to be added to the map\n   * @param hash - The hash value at which to map the schema\n   */\n  addSchema(schema: S, hash: string) {\n    const key = get(schema, ID_KEY, hash);\n    const identifiedSchema = { ...schema, [ID_KEY]: key };\n    const existing = this.schemaMap[key];\n    if (!existing) {\n      this.schemaMap[key] = identifiedSchema;\n    } else if (!isEqual(existing, identifiedSchema)) {\n      console.error('existing schema:', JSON.stringify(existing, null, 2));\n      console.error('new schema:', JSON.stringify(identifiedSchema, null, 2));\n      throw new Error(\n        `Two different schemas exist with the same key ${key}! What a bad coincidence. If possible, try adding an $id to one of the schemas`\n      );\n    }\n  }\n\n  /** Returns the current `schemaMap` to the caller\n   */\n  getSchemaMap() {\n    return this.schemaMap;\n  }\n\n  /** Implements the `ValidatorType` `isValid()` method to capture the `schema` in the `schemaMap`. Throws an error when\n   * the `rootSchema` is not the same as the root schema provided during construction.\n   *\n   * @param schema - The schema to record in the `schemaMap`\n   * @param _formData - The formData parameter that is ignored\n   * @param rootSchema - The root schema associated with the schema\n   * @throws - Error when the given `rootSchema` differs from the root schema provided during construction\n   */\n  isValid(schema: S, _formData: T, rootSchema: S): boolean {\n    if (!isEqual(rootSchema, this.rootSchema)) {\n      throw new Error('Unexpectedly calling isValid() with a rootSchema that differs from the construction rootSchema');\n    }\n    this.addSchema(schema, hashForSchema<S>(schema));\n\n    return false;\n  }\n\n  /** Implements the `ValidatorType` `rawValidation()` method to throw an error since it is never supposed to be called\n   *\n   * @param _schema - The schema parameter that is ignored\n   * @param _formData - The formData parameter that is ignored\n   */\n  rawValidation<Result = any>(_schema: S, _formData?: T): { errors?: Result[]; validationError?: Error } {\n    throw new Error('Unexpectedly calling the `rawValidation()` method during schema parsing');\n  }\n\n  /** Implements the `ValidatorType` `toErrorList()` method to throw an error since it is never supposed to be called\n   *\n   * @param _errorSchema - The error schema parameter that is ignored\n   * @param _fieldPath - The field path parameter that is ignored\n   */\n  toErrorList(_errorSchema?: ErrorSchema<T>, _fieldPath?: string[]): RJSFValidationError[] {\n    throw new Error('Unexpectedly calling the `toErrorList()` method during schema parsing');\n  }\n\n  /** Implements the `ValidatorType` `validateFormData()` method to throw an error since it is never supposed to be\n   * called\n   *\n   * @param _formData - The formData parameter that is ignored\n   * @param _schema - The schema parameter that is ignored\n   * @param _customValidate - The customValidate parameter that is ignored\n   * @param _transformErrors - The transformErrors parameter that is ignored\n   * @param _uiSchema - The uiSchema parameter that is ignored\n   */\n  validateFormData(\n    _formData: T,\n    _schema: S,\n    _customValidate?: CustomValidator<T, S, F>,\n    _transformErrors?: ErrorTransformer<T, S, F>,\n    _uiSchema?: UiSchema<T, S, F>\n  ): ValidationData<T> {\n    throw new Error('Unexpectedly calling the `validateFormData()` method during schema parsing');\n  }\n}\n","import forEach from 'lodash/forEach';\nimport isEqual from 'lodash/isEqual';\n\nimport { FormContextType, RJSFSchema, StrictRJSFSchema } from '../types';\nimport { PROPERTIES_KEY, ITEMS_KEY } from '../constants';\nimport ParserValidator, { SchemaMap } from './ParserValidator';\nimport { retrieveSchemaInternal, resolveAnyOrOneOfSchemas } from '../schema/retrieveSchema';\n\n/** Recursive function used to parse the given `schema` belonging to the `rootSchema`. The `validator` is used to\n * capture the sub-schemas that the `isValid()` function is called with. For each schema returned by the\n * `retrieveSchemaInternal()`, the `resolveAnyOrOneOfSchemas()` function is called. For each of the schemas returned\n * from THAT call have `properties`, then each of the sub-schema property objects are then recursively parsed.\n *\n * @param validator - The `ParserValidator` implementation used to capture `isValid()` calls during parsing\n * @param recurseList - The list of schemas returned from the `retrieveSchemaInternal`, preventing infinite recursion\n * @param rootSchema - The root schema from which the schema parsing began\n * @param schema - The current schema element being parsed\n */\nfunction parseSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ParserValidator<T, S, F>,\n  recurseList: S[],\n  rootSchema: S,\n  schema: S\n) {\n  const schemas = retrieveSchemaInternal<T, S, F>(validator, schema, rootSchema, undefined, true);\n  schemas.forEach((schema) => {\n    const sameSchemaIndex = recurseList.findIndex((item) => isEqual(item, schema));\n    if (sameSchemaIndex === -1) {\n      recurseList.push(schema);\n      const allOptions = resolveAnyOrOneOfSchemas<T, S, F>(validator, schema, rootSchema, true);\n      allOptions.forEach((s) => {\n        if (PROPERTIES_KEY in s && s[PROPERTIES_KEY]) {\n          forEach(schema[PROPERTIES_KEY], (value) => {\n            parseSchema<T, S, F>(validator, recurseList, rootSchema, value as S);\n          });\n        }\n      });\n      if (ITEMS_KEY in schema && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\n        parseSchema<T, S, F>(validator, recurseList, rootSchema, schema.items as S);\n      }\n    }\n  });\n}\n\n/** Parses the given `rootSchema` to extract out all the sub-schemas that maybe contained within it. Returns a map of\n * the hash of the schema to schema/sub-schema.\n *\n * @param rootSchema - The root schema to parse for sub-schemas used by `isValid()` calls\n * @returns - The `SchemaMap` of all schemas that were parsed\n */\nexport default function schemaParser<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  rootSchema: S\n): SchemaMap<S> {\n  const validator = new ParserValidator<T, S, F>(rootSchema);\n  const recurseList: S[] = [];\n\n  parseSchema(validator, recurseList, rootSchema, rootSchema);\n\n  return validator.getSchemaMap();\n}\n"],"names":["isObject","thing","File","Date","Array","isArray","allowAdditionalItems","schema","additionalItems","console","warn","asNumber","value","undefined","test","n","Number","valid","isNaN","ADDITIONAL_PROPERTY_FLAG","ADDITIONAL_PROPERTIES_KEY","ALL_OF_KEY","ANY_OF_KEY","CONST_KEY","DEFAULT_KEY","DEFINITIONS_KEY","DEPENDENCIES_KEY","ENUM_KEY","ERRORS_KEY","ID_KEY","IF_KEY","ITEMS_KEY","JUNK_OPTION_ID","NAME_KEY","ONE_OF_KEY","PROPERTIES_KEY","REQUIRED_KEY","SUBMIT_BTN_OPTIONS_KEY","REF_KEY","RJSF_ADDITONAL_PROPERTIES_FLAG","ROOT_SCHEMA_PREFIX","UI_FIELD_KEY","UI_WIDGET_KEY","UI_OPTIONS_KEY","UI_GLOBAL_OPTIONS_KEY","getUiOptions","uiSchema","globalOptions","Object","keys","filter","key","indexOf","reduce","options","error","substring","canExpand","formData","additionalProperties","expandable","maxProperties","length","createErrorHandler","handler","addError","message","push","acc","isPlainObject","formObject","deepEquals","a","b","isEqualWith","obj","other","splitKeyElementFromObject","object","remaining","omit","findSchemaDefinition","$ref","rootSchema","ref","startsWith","decodeURIComponent","Error","current","jsonpointer","get","theRef","subSchema","getMatchingOption","validator","discriminatorField","i","option","has","discriminator","isValid","requiresAnyOf","anyOf","map","required","augmentedSchema","shallowClone","allOf","slice","assign","getFirstMatchingOption","getDiscriminatorFieldFromSchema","maybeString","isString","guessType","getSchemaType","type","const","enum","properties","includes","find","mergeSchemas","obj1","obj2","left","right","union","retrieveSchema","rawFormData","retrieveSchemaInternal","resolveCondition","expandAllBranches","if","expression","then","else","otherwise","resolvedSchemaLessConditional","conditionValue","resolvedSchemas","schemas","concat","conditionalSchema","s","flatMap","getAllPermutationsOfXxxOf","listOfLists","allPermutations","permutations","list","element","times","forEach","permutation","resolveSchema","resolveReference","resolveDependencies","allOfSchemaElements","allOfSubschema","localSchema","refSchema","resolveAllReferences","resolvedSchema","updatedProps","transform","result","items","stubExistingAdditionalProperties","theSchema","aFormData","set","mergeAllOf","deep","e","resolvedSchemaWithoutAllOf","hasAdditionalProperties","resolveAnyOrOneOfSchemas","anyOrOneOf","oneOf","item","dependencies","remainingSchema","processDependencies","dependencyKey","remainingDependencies","dependencyValue","withDependentProperties","withDependentSchema","additionallyRequired","from","Set","dependentSchemas","dependent","dependentSchema","resolvedOneOfs","subschema","resolvedOneOf","withExactlyOneSubschema","validSubschemas","conditionPropertySchema","conditionSchema","dependentSubschema","JUNK_OPTION","$id","__not_really_there__","calculateIndexScore","totalScore","score","formValue","newSchema","getClosestMatchingOption","newScore","default","selectedOption","resolvedOptions","allValidIndexes","validList","index","testOptions","match","scoreCount","bestIndex","scoreData","bestScore","add","size","isFixedItems","every","mergeDefaultsWithFormData","defaults","mergeExtraArrayDefaults","defaultsArray","mapped","idx","mergeObjects","concatArrays","toMerge","isConstant","isSelect","altSchemas","isMultiSelect","uniqueItems","AdditionalItemsHandling","getInnerSchemaForArrayItem","Ignore","maybeAddDefaultToObject","computedDefault","includeUndefinedValues","isParentRequired","requiredFields","experimental_defaultFormStateBehavior","emptyObjectFields","isSelfOrParentRequired","isEmpty","computeDefaults","rawSchema","parentDefaults","_recurseList","schemaToCompute","updatedRecurseList","refName","itemSchema","objectDefaults","_schema$required","additionalPropertiesSchema","formDataRequired","_schema$required2","_experimental_default","schemaItem","Fallback","ignoreMinItemsFlagSet","arrayMinItems","populate","defaultsLength","minItems","defaultEntries","fillerSchema","Invert","fillerDefault","fillerEntries","fill","getDefaultFormState","mergeExtraDefaults","isCustomWidget","isFilesArray","itemsSchema","format","getDisplayLabel","uiOptions","label","displayLabel","schemaType","mergeValidationData","validationData","additionalErrorSchema","errors","oldErrors","errorSchema","oldErrorSchema","toErrorList","NO_VALUE","Symbol","sanitizeDataForNewSchema","oldSchema","data","newFormData","removeOldSchemaData","nestedData","oldKeyedSchema","newKeyedSchema","oldSchemaTypeForKey","newSchemaTypeForKey","itemData","newOptionDefault","oldOptionDefault","newOptionConst","oldOptionConst","oldSchemaItems","newSchemaItems","oldSchemaType","newSchemaType","maxItems","newValue","aValue","itemValue","toIdSchemaInternal","idPrefix","idSeparator","id","_schema","sameSchemaIndex","findIndex","isEqual","idSchema","name","field","fieldId","toIdSchema","toPathSchemaInternal","pathSchema","replace","xxxOf","property","toPathSchema","SchemaUtils","constructor","getValidator","doesSchemaUtilsDiffer","createSchemaUtils","dataURItoBlob","dataURI","splitted","split","params","param","decodeURI","binary","atob","array","charCodeAt","blob","window","Blob","Uint8Array","replaceStringParameters","inputString","output","parts","partIndex","part","join","englishStringTranslator","stringToTranslate","enumOptionsValueForIndex","valueIndex","allEnumOptions","emptyValue","val","enumOptionsDeselectValue","selected","v","enumOptionsIsSelected","some","sel","enumOptionsIndexForValue","multiple","selectedIndexes","opt","String","enumOptionsSelectValue","isNil","all","updated","sort","ErrorSchemaBuilder","initialSchema","resetAllErrors","ErrorSchema","getOrCreateErrorBlock","pathOfError","hasPath","errorBlock","cloneDeep","addErrors","errorOrList","errorsList","setErrors","listToAdd","clearErrors","rangeSpec","spec","multipleOf","step","minimum","min","maximum","max","getInputProps","defaultType","autoDefaultStepAny","inputProps","inputType","autocomplete","autoComplete","DEFAULT_OPTIONS","props","disabled","submitText","norender","getSubmitButtonOptions","getTemplate","registry","templates","widgetMap","boolean","checkbox","radio","select","hidden","string","text","password","email","hostname","ipv4","ipv6","uri","textarea","date","datetime","time","color","file","number","updown","range","integer","checkboxes","files","mergeWidgetOptions","AWidget","MergedWidget","defaultOptions","defaultProps","_jsx","getWidget","widget","registeredWidgets","ReactIs","isForwardRef","createElement","isMemo","registeredWidget","hashString","hash","chr","toString","hashForSchema","allKeys","JSON","stringify","hasWidget","err","idGenerator","suffix","theId","descriptionId","errorId","examplesId","helpId","titleId","ariaDescribedByIds","includeExamples","examples","optionId","optionIndex","labelValue","hideLabel","fallback","localToUTC","dateString","toJSON","toConstant","optionsList","schemaWithEnumNames","enumNames","process","aSchemaDef","aSchema","title","orderProperties","order","arrayToHash","arr","prev","curr","errorPropList","propertyHash","orderFiltered","prop","orderHash","rest","restIndex","lastIndexOf","complete","splice","pad","num","width","parseDateString","includeTime","year","month","day","hour","minute","second","getTime","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","schemaRequiresTrueValue","schemaSome","shouldRender","component","nextProps","nextState","state","toDateString","dateObject","utcTime","UTC","fieldPath","errorList","stack","childSchema","toErrorSchema","builder","path","toPath","unwrapErrorHandler","errorHandler","utcToLocal","jsonDate","yyyy","getFullYear","MM","getMonth","dd","getDate","hh","getHours","mm","getMinutes","ss","getSeconds","SSS","getMilliseconds","validationDataMerge","withIdRefPrefixObject","node","realObj","withIdRefPrefix","withIdRefPrefixArray","schemaNode","TranslatableString","ParserValidator","schemaMap","addSchema","identifiedSchema","existing","getSchemaMap","_formData","rawValidation","_errorSchema","_fieldPath","validateFormData","_customValidate","_transformErrors","_uiSchema","parseSchema","recurseList","allOptions","schemaParser"],"mappings":"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"}